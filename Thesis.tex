% Setup and import
\documentclass[12pt,a4paper]{report}
\usepackage[english, italian]{babel}
\usepackage{csquotes}
\usepackage[dvipsnames]{xcolor}
\usepackage{newlfont}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{biblatex}
\usepackage{forest}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{listings}
\usepackage{tikz}
\textwidth=450pt\oddsidemargin=0pt

% Dedication template
\newenvironment{dedication}
{
    \clearpage            % we want a new page
    \thispagestyle{empty} % no header and footer
    \vspace*{\stretch{1}} % some space at the top
    \itshape              % the text is in italics
    \raggedleft           % flush to the right margin
}
{
    \par                  % end the paragraph
    \vspace{\stretch{3}}  % space at bottom is three times that at the top
    \clearpage            % finish off the page
}

% Project Tree definition
\definecolor{folderbg}{RGB}{124,166,198}
\definecolor{folderborder}{RGB}{110,144,169}

\tikzset{
  folder/.pic={
    \filldraw[draw=folderborder,top color=folderbg!50,bottom color=folderbg]
      (-1.05*4pt,0.24pt+5pt) rectangle ++(.75*4pt,-0.24pt-5pt);  
    \filldraw[draw=folderborder,top color=folderbg!50,bottom color=folderbg]
      (-1.15*4pt,-4pt) rectangle (1.15*4pt,4pt);
  }
}

% Definition init
\newtheorem{definition}{Definition}[chapter]
\newtheorem{remark}{Remark}[definition]

% Setup algorithm numeration to follow the definition and remark ones
\renewcommand{\thealgorithm}{\arabic{chapter}.\arabic{algorithm}}

% Setup listings code style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{White},
    numberstyle=\tiny\color{Gray},
    commentstyle=\color{OliveGreen},
    keywordstyle=\color{MidnightBlue},
    stringstyle=\color{OrangeRed},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=false,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}


% ForEach construct definition
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

% Tikz submodule import
\usetikzlibrary{automata, positioning, arrows}

\addbibresource{Bibliography.bib}

% Document start 
\begin{document}


% Title page
\begin{titlepage}
    \begin{center}
        {{\Large{\textsc{Alma Mater Studiorum $\cdot$ Universit\`a di
                            Bologna}}}} \rule[0.1cm]{15.8cm}{0.1mm}
        \rule[0.5cm]{15.8cm}{0.6mm}
        {\small{\bf SCUOLA DI SCIENZE\\
                Corso di Laurea in Informatica }}
    \end{center}
    \vspace{15mm}
    \begin{center}
        {\LARGE{\bf Choreia: A Static Analyzer }}\\
        \vspace{3mm}
        {\LARGE{\bf to Generate Choreography Automata}}\\
        \vspace{3mm}
        {\LARGE{\bf from Go Source Code}}\\
    \end{center}
    \vspace{40mm}
    \par
    \noindent
    \begin{minipage}[t]{0.47\textwidth}
        {\large{\bf Relatore:\\
                Prof. Ivan Lanese}}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.47\textwidth}\raggedleft
        {\large{\bf Presentata da:\\
                Enea Guidi}}
    \end{minipage}
    \vspace{20mm}
    \begin{center}
        {\large{\bf Sessione III\\
                Anno Accademico 2020/2021 }}
    \end{center}
\end{titlepage}


% Dedication page
\begin{dedication}
    Alla mia famiglia e agli amici che\\
    mi hanno accompagnato in questo viaggio
\end{dedication}


% Abstract
\begin{abstract}
    Le coreografie sono un paradigma emergente per la descrizione dei sistemi concorrenti che sta prendendo piede negli ultimi anni. Lo scopo principale è quello di fornire al programmatore uno strumento che permetta di capire in maniera immediata la \emph{coreografia} dei partecipanti all'interno del sistema e come questi interagiscono tra loro. Partendo dai singoli partecipanti, e le loro \emph{viste locali}, è possibile ricomporre in maniera bottom-up l'intera Choreography (o \emph{vista globale}) del sistema.
    Un ulteriore vantaggio delle coreografie è che, quando rispettano alcune proprietà definite, danno garanzie sull'assenza di tipici problemi di concorrenza quali Deadlocks, Liveness e Race Conditions.
    Esistono vari modelli formali di coreografie, questa tesi tratta nello specifico i \emph{Choreography Automata}, basati su \emph{Finite State Automata} (FSA).
    In questa tesi viene presentato Choreia: un tool di analisi statica che, partendo da un codice sorgente Go, ricava il Choreography Automata del sistema concorrente in maniera bottom-up.
\end{abstract}

% Auto-generated table of contents
\tableofcontents

% Introduction chapter
\chapter{Introduzione}
Negli ultimi anni si è visto un progressivo aumento nell'utilizzo di \emph{sistemi distribuiti} e delle cosidette \emph{architetture orientate ai microservizi} così come un rinnovato interesse verso lo sviluppo concorrente.\\
Questo nuovo interesse ha portato cambiamenti  nei linguaggi di programmazione e nel \emph{language design}, si è cercato infatti di venire incontro alle richieste dei programmatori facilitando l'approccio del linguaggio alla concorrenza. Ricordiamo infatti che alcuni linguaggi non offrivano funzionalità native o talvolta le API fornite erano troppo complesse ed intricate per garantirne un utilizzo chiaro e, più in generale, la concorrenza era un \emph{afterthought} durante la progettazione di un linguaggio. Alcuni esempi pratici di queste trasformazioni possono essere visti in nuovi linguaggi di programmazione come Go ed Elixir che offrono un'approccio semplificato e più chiaro alla concorrenza ma anche in linguaggi più consolidati come C++, che con lo standard 20 ha introdotto construtti che facilitano l'utilizzo rispetto alle implementazioni precedenti.\\
Tuttavia sviluppare è estremamente complesso sviluppare un sistema concorrente (o distribuito) esente da errori, allo stesso modo si presentano varie problematiche legate al \emph{debugging} dello stesso, in entrambi i casi si fatica a riprodurre il bug o a testare tutte le casiste possibili. Questo aspetto di difficoltà è intrinsicamente legato alla natura non deterministica di un sistema concorrente che rende difficile riprodurre una definita situazione. Inoltre questi problemi di riproducibilità e validazione crescono esponenzialmente in difficoltà al crescere della complessità del sistema stesso.\bigskip \\
Da queste probllematiche nasce dunque la necessità di avere strumenti che assistano lo sviluppatore, per questo motivo parallelamente al trend sopra descritto, sono stati proposti nuovi \emph{paradigmi} e \emph{modelli teorici} che mirano ad esemplificare la scrittura di programmi concorrenti, tra questi troviamo le \emph{coreografie}.\\
L'idea alla base delle coreografie è quella di definire un metodo standard per rappresentare le interazioni tra due o più processi durante l'esecuzione in un sistema concorrente. Le coreografie forniscono al programmatore la possibilità di osservare e analizzare le interazioni che avvengono tra i partecipanti ma allo stesso modo possono fornire uno strumento per la descrizione delle stesse durante la fase progettuale.\bigskip \\
Tipicamente nelle coreografie i proocessi comunicano tra loro attraverso \emph{message pasing}, avremo quindi una primitiva del tipo:
\begin{center}
    $Alice \rightarrow Bob : message$
\end{center}
per indicare che Alice sta inviando un messaggio "mssage" a Bob. La caratteristica che distingue le coreografie dagli altri paradigmi consiste nel fatto che quest'ultime forniscono 2 tipi di \emph{view} diverse:
\begin{itemize}
    \item \textbf{View globale}: la descrizione dal punto di visto \emph{olistico} dell'intero sistema
    \item \textbf{View locale}: la descrizione di un singolo componente \emph{in isolamento}
\end{itemize}
È sempre possibile, partendo dalla global view, ottenere una sua local view attraverso l'operazione di \emph{proiezione} ed è anche possibile unire più global view insieme mediante l'operazione di \emph{composizione}. Oltre a queste operazioni una coreografia che soddisfa certe proprietà ed è dunque \emph{ben formata} permette di fare assunzioni riguardo all'assenza dei classici problemi di programmazione concorrente come \emph{deadlocks}, \emph{race conditions} e \emph{liveness} fornendo al programmatore uno strumento di verifica per il suo codice.\bigskip \\
In questa tesi viene presentato \emph{Choreia}, un tool di analisi statica che permette di ricavare da del codice sorgente Go il Choregraphy Automata ad esso associato. I Choreography Automata sono un \emph{modello} per descrivere le coreografie basato su \emph{automi a stati finiti (FSA)}, un particolare vantaggio dei Choreography Automata è la possibilità di poter riutilizzare tutte le nozioni teoriche già esistente in letteratura sugli automi a stati finiti. Oltre ad una descrizioni approfondita del tool e delle nozioni alla base dello stesso verrano introdotte anche le \emph{Communicating Finite State Machine} per la descrizione delle local views e gli algoritmi di proiezione e composizione. Sempre in questa tesi verrà presentato un algoritmo per la composizione di multiple local views in una unica global view, andando difatti a definire un'operazione inversa alla proiezione, quest'ultima sarà direttamente derivata dall'algoritmo di composizone tra global views.


% "Preliminaries and Notation" chapter
\input{Chapters/Preliminaries.tex}

% "Technology stack" chapter
\input{Chapters/Technologies.tex}

% "Changes and adaptations" chapter
\input{Chapters/Adaptations.tex}

% "Tool description" chapter
\input{Chapters/Tool.tex}

% "Conclusion and future works" chapter
\input{Chapters/Conclusions.tex}


\printbibliography


\end{document}