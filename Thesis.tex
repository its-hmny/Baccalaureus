% Setup and import
\documentclass[12pt,a4paper]{report}
\usepackage[english, italian]{babel}
\usepackage{newlfont}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}
\textwidth=450pt\oddsidemargin=0pt

% Dedication template
\newenvironment{dedication}
{
    \clearpage            % we want a new page
    \thispagestyle{empty} % no header and footer
    \vspace*{\stretch{1}} % some space at the top
    \itshape              % the text is in italics
    \raggedleft           % flush to the right margin
}
{
    \par                  % end the paragraph
    \vspace{\stretch{3}}  % space at bottom is three times that at the top
    \clearpage            % finish off the page
}


% Definition init
\newtheorem{definition}{Definition}[chapter]
\newtheorem{remark}{Remark}[definition]

% ForEach construct definition
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

% Tikz submodule import
\usetikzlibrary{automata, positioning, arrows}

% ! To import subfiles as section
% \subfile{sections/section2} The relative path to file

% Document start 
\begin{document}


% Title page
\begin{titlepage}
    \begin{center}
        {{\Large{\textsc{Alma Mater Studiorum $\cdot$ Universit\`a di
                            Bologna}}}} \rule[0.1cm]{15.8cm}{0.1mm}
        \rule[0.5cm]{15.8cm}{0.6mm}
        {\small{\bf SCUOLA DI SCIENZE\\
                Corso di Laurea in Informatica }}
    \end{center}
    \vspace{15mm}
    \begin{center}
        {\LARGE{\bf Choreia: A Static Analyzer }}\\
        \vspace{3mm}
        {\LARGE{\bf to generate Choreography Automata}}\\
        \vspace{3mm}
        {\LARGE{\bf from Go source code}}\\
    \end{center}
    \vspace{40mm}
    \par
    \noindent
    \begin{minipage}[t]{0.47\textwidth}
        {\large{\bf Relatore:\\
                Chiar.mo Prof.\\
                Ivan Lanese}}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.47\textwidth}\raggedleft
        {\large{\bf Presentata da:\\
                Enea Guidi}}
    \end{minipage}
    \vspace{20mm}
    \begin{center}
        {\large{\bf Sessione III\\ % TODO: check graduation session number
                Anno Accademico 2020/2021 }}
    \end{center}
\end{titlepage}


% Dedication page
\begin{dedication}
    Agli amici che ho conosciuto e che\\
    mi hanno accompagnato in questo viaggio
\end{dedication}


% Abstract
\begin{abstract}
    Le Choreographies sono un paradigma emergente per la descrizione dei sistemi concorrenti. Lo scopo principale è quello di fornire al programmatore uno strumento il quale permetta di capire in maniera immediata la "coreografia" dei participanti nel sistema e come questi interagiscano tra loro. Partendo dai singoli partecipanti e loro Choreographies \emph{locali} è possibile ricomporre in maniera bottom-up l'intera Choreography \emph{globale} del sistema.
    Un ulteriore vantaggio delle Choreographies è che, se rispettano alcune proprietà ben definite, permettono di fare assunzioni sull'assenza di tipici problemi di concorrenza quali Deadlocks e Race Conditions.
    Esistono vari modelli formali di Choreographies, questa tesi tratta nello specifico i \emph{Choreography Automata}, basati su \emph{Finite State Automata} (FSA).
    In questa tesi viene presentato Choreia: un tool di analisi statica che, partendo da un codice sorgente Go, ricava il Choreography Automata del sisitema concorrente in maniera bottom-up.
\end{abstract}

% Auto-generated table of contents
\tableofcontents

% Introduction chapter
\chapter{Introduzione} % TODO Should be improved
Negli ultimi anni si è visto un interesse sempre più pronunciato verso lo sviluppo di sistemi concorrenti e distribuiti, questo si riflette nella progettazione a microservizi o in linguaggi di programmazione più recenti come Go, Rust o C++ 20 i quali implementano tutti, in forme disparate, un approccio alla concorrenza facilitato e univoco evitando la complessità e frammentazione che può derivare dall'utilizzo di librerie esterne e non standardizzate.\\
% ? Keep this paragraph
Prendendo per esempio Go, talvolta chiamato anche golang, un linguaggio di programmazione creato nel 2009 da Robert Griesemer, Rob Pike e Ken Thompson, che negli anni successivi prende una forte trazione, fino a essere supportato da Google, sopratutto nel settore del web-development e system programming. Alcuni dei fattori da successo sono una compilazione ed esecuzione veloce, una grammatica semplice e snella e un approccio \emph{built-in} alla concorrenza con tipi e primitive fornite direttamente dalla standard library. Quest'ultima infatti fornisce un solo tipo di dato \emph{chan} che può essere \emph{buffered} o \emph{unbuffered}, la comunicazione che avviene su questi canali è rispettivamente asincrona e sincrona.\\
Parallelamente a questo rinnovato interesse verso la programmazione concorrente e distribuita nasce l'esigenza di formalizzare dei modelli teorici che possano supportare la progettazione, gestione e manutenzione di sistemi concorrenti. Uno di questi modelli sono le \emph{Choreographies}, le quali facilitano la rappresentazione e descrizione di sistemi concorrenti in cui i singoli \emph{attori} comunicano tra di loro. Un aspetto distintivo delle Choreographies è la coesistenza di due \emph{view}:
\begin{itemize}
    \item Vista \textbf{globale}: descrive la coordinazione necessaria tra i componenti di un sistema
    \item Vista \textbf{locale}: descrive il comportamento di un singolo componente \emph{in isolamento}
\end{itemize}
% ? Add the parts about Choreography Automatas properties and how them can help making assumption on the Go program
L'obiettivo di questa tesi è quello di progettare e implementare un tool che permetta, preso un sorgente Go e per mezzo di analisi statica, di estrarre un Choreography Automata, ovvero un automa a stati finiti che rappresenta la Choreography in modo grafico, più chiaro e immediato rispetto alla lettura del codice sorgente.


% Preliminaries and Notation chapter
\chapter{Nozioni preliminari e notazione}
% Finite State Automata (+ related) section
\section{FSA non deterministici e deterministici}
Prima di introdurre le Choreographies e i Choreographies Automata è necessario fare un breve richiamo di alcune nozioni fondamentali quali la nozione di Automa a Stati Finiti (FSA) e alcune trasformazioni possibili sugli stesssi.
Gli automi a stati finiti sono la descrizione di un sistema dinamico che si evolve nel tempo, esiste un parallelo tra gli automi e i calcolatori moderni, per esempio il flusso d'esecuzione di un programma può essere rappresentato attraverso un automa.
Alcune applicazioni pratiche di questi automi possono essere regular expression (RegEx o RegExp), lexer e parser solo per citarne alcuni ma possono anche essere impiegati, come vedremo in questa tesi, anche nel campo della concorrenza.

Si noti che sebbene per gli scopi di questa tesi gli automi a stati finiti sono dei costrutti sufficentemente potenti esistono tuttavia altre classi di automi ai quali corrispondo altrettante classi di inguaggio, anzi gli automi a stati finiti sono tra i più semplici.

\begin{definition}[Finite State Automata]
    Un automa a stati finiti (FSA) è una tupla A = $\langle \mathcal{S}, s\textsubscript0, \mathcal{L}, \delta \rangle$ dove:
    \begin{itemize}
        \item $\mathcal{S}$ è un insieme finito di stati
        \item $s\textsubscript0 \in \mathcal{S}$ è lo stato iniziale dell'automa
        \item $\mathcal{L}$ è l'alfabeto finito, talvolta detto anche insieme di label ($\epsilon \notin \mathcal{L}$)
        \item $\delta \subseteq \mathcal{S} \times (L \cup \{\epsilon\}) \times \mathcal{S}$ è la funzione di transizione ($\epsilon$ denota la stringa vuota)
    \end{itemize}
\end{definition}

Tipicamente, oltre a quanto definito sopra, è solito trovare anche un insieme di stati di terminazione (o accettazione), detto $\mathcal{F}$. Visto che in questo caso detto insieme non è stato definito assumiamo che ogni $s \in \mathcal{S}$ sia uno stato di accettazione. Inoltre va notato che questa definizione coincide con quella di automa a stati finiti \emph{non deterministico}, solitamente indicato in letteratura con la sigla NFA (\emph{Non Deterministic Finite Automata}) e distinto dalla nozione di DFA (\emph{Deterministic Finite Automata}).

\begin{definition}[Deterministic Finite Automata]
    Un automa a stati finiti deterministico è una tupla D = $\langle \mathcal{S}, s\textsubscript0, \mathcal{L}, \delta \rangle$ con $\delta \subseteq \mathcal{S} \times L \times \mathcal{S}$
\end{definition}

Le varianti deterministiche si distinguono dalle loro controparti non deterministiche dal fatto che non ammettono l'utilizzo di $\epsilon$ transizioni e l'utilizzo più transizioni \emph{uscenti} dallo stesso stato con la medesima etichetta. Sebbene queste due varianti siano tra loro equivalenti, l'utilizzo di una variante rispetto all'altra può essere determinato da fattori come necessità di una maggiore elasticità (gli NFA sono meno stringenti rispetto ai DFA) o, al contrario, di una migliore chiarezza (i DFA sono più immediati rispetto alla loro controparte).

In ogni caso è sempre possibile, dato un NFA qualunque, un DFA ad esso equivalente. L'algoritmo che permette di fare questa trasformazione fa uso estensivo di \emph{$\epsilon$ closure} e della funione \emph{mossa} che andiamo a definire di seguito:

\begin{definition}[$\epsilon$ closure]
    Fissato un NFA N = $\langle \mathcal{S}, s\textsubscript0, \mathcal{L}, \delta \rangle$ ed uno stato $s \in \mathcal{S}$ si dice $\epsilon$ closure di s, indicata con $\epsilon$-clos(s) il più piccolo $\mathcal{R} \subseteq \mathcal{S}$ tale che:
    \begin{itemize}
        \item $s \in \epsilon$-clos(s)
        \item se x $\in \epsilon$-clos(s) allora $\delta(x, \epsilon) \subseteq \epsilon$-clos(s)
    \end{itemize}
\end{definition}

\begin{remark}
    Se $\mathcal{X}$ è un insieme di stati definiamo $\epsilon$-clos($\mathcal{X}$) come $\bigcup_{x \in \mathcal{X}} \epsilon \mbox{-clos(x)}$.
\end{remark}

\begin{definition}[Mossa]
    Dato un insieme di stati $\mathcal{X} \subseteq \mathcal{S}$ e un simbolo $\alpha \in \mathcal{L}$ definiamo la funzione \emph{mossa}: $\mathcal{P(S)} \times \mathcal{L} \longrightarrow \mathcal{P(S)}$ tale che: \emph{mossa}$(\mathcal{X}, \alpha) = \bigcup_{x \in \mathcal{X}}(\delta(x, \alpha))$
\end{definition}

\newpage
L'algoritmo che permette di ricavare un DFA da un qualsiasi NFA è il seguente:
\begin{algorithm}
    \caption{Costruzione per sottoinsiemi}\label{alg:cap}
    \begin{algorithmic}
        \State $x \gets$ $\epsilon$-clos($s\textsubscript0$) \Comment{Lo stato iniziale del DFA}
        \State $\mathcal{T} \gets \{ x \}$                   \Comment{Un insieme di $\epsilon$-clos}
        \While{$\exists$ t $\in \mathcal{T}$ non marcato}
        \State marca(t)
        \ForEach {$\alpha \in \mathcal{L} $}
        \State $r \gets \epsilon$-clos(mossa(t, $\alpha$))
        \If {$r \notin \mathcal{T}$}
        \State $\mathcal{T} \gets \mathcal{T} \cup \{r\}$
        \EndIf
        \State $\delta(t, \alpha) \gets r$  \Comment{Denota che la $\delta$ del DFA con input t ed $\alpha$ da output r}
        \EndFor
        \EndWhile
    \end{algorithmic}
\end{algorithm}

Si noti che $x$, $\mathcal{T}$ e $\delta$ saranno rispettivamente lo stato iniziale, l'insieme degli stati e la funzione di transizione del DFA corrispondente mentre chiaramente $\mathcal{L}$ rimarrà invariato. Quindi il DFA ottenuto in uoutput sarà D = $\langle \mathcal{T}, x, \mathcal{L}, \delta \rangle$.

\subsection{Esempi}
Per concludere questa sezione mostriamo di seguito un esempio dei vari concetti mostrati in questa sezione. Il seguente è un NFA N un grado di riconoscere la Regular Expression $(a|b)^*ba$:
\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[->,>=stealth',node distance=2cm,scale=1, transform shape]
        \node[state,initial] (q0) {$q_0$};
        \node[state] (q1) [right of=q0] {$q_1$};
        \node[state] (q2) [above right of=q1] {$q_2$};
        \node[state] (q3) [right of=q2] {$q_3$};
        \node[state] (q4) [below right of=q1] {$q_4$};
        \node[state] (q5) [right of=q4] {$q_5$};
        \node[state] (q6) [above right of=q5] {$q_6$};
        \node[state] (q7) [right of=q6] {$q_7$};
        \node[state] (q8) [right of=q7] {$q_8$};
        \node[state, accepting] (q9) [right of=q8] {$q_9$};
        \draw
        (q0) edge[above] node{$\epsilon$} (q1)
        (q0) edge[bend left=60, above] node{$\epsilon$} (q7)
        (q1) edge[above] node{$\epsilon$} (q2)
        (q2) edge[above] node{$a$} (q3)
        (q3) edge[above] node{$\epsilon$} (q6)
        (q1) edge[above] node{$\epsilon$} (q4)
        (q4) edge[above] node{$b$} (q5)
        (q5) edge[above] node{$\epsilon$} (q6)
        (q6) edge[above] node{$\epsilon$} (q7)
        (q6) edge[above] node{$\epsilon$} (q1)
        (q7) edge[above] node{$b$} (q8)
        (q8) edge[above] node{$a$} (q9);
    \end{tikzpicture}
    \caption{Un possibile NFA che riconosce la RegEx $(a|b)^*ba$}
    \label{fig:NFA}
\end{figure}

Questo è un possibile NFA in grado di riconoscere questo linguaggio, esistono infiniti NFA diversi tra loro in grado di riconoscere questo linguaggio. Vediamo ora invece un DFA D equivalente ad N calcolato tramite l'algorimo di \emph{Costruzione per sottoinsiemi}
\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,scale=1, transform shape]
        \node[state,initial] (A) {$A$};
        \node[state] (B) [above right of=A] {$B$};
        \node[state] (C) [right of=A] {$C$};
        \node[state, accepting] (D) [above right of=C] {$D$};
        \draw
        (A) edge[above] node{$a$} (B)
        (A) edge[above] node{$b$} (C)
        (B) edge[loop above] node{$a$} (B)
        (B) edge[above] node{$b$} (C)
        (C) edge[loop below] node{$b$} (C)
        (C) edge[bend right, above] node{$a$} (D)
        (D) edge[above] node{$a$} (B)
        (D) edge[bend right,above] node{$b$} (C);
    \end{tikzpicture}
    \begin{tikzpicture}
        \node (NFA to DFA) [shape=rectangle,draw] {
            \begin{tabular}{c c}
                Stati NFA           & Stati DFA \\
                \{ 0,1,2,4,7 \}     & A         \\
                \{ 1,2,3,4,6,7 \}   & B         \\
                \{ 1,2,4,5,6,7,8 \} & C         \\
                \{ 1,2,3,4,6,7,9 \} & D
            \end{tabular}
        };
    \end{tikzpicture}
    \caption{Il DFA equivalente a quello in figura 2.1}
    \label{fig:DFA}
\end{figure}

\section{Choreography Automata}
% Changes and adaptation chapter
\chapter{Adattazioni e modifiche}
TODO


% Technology stack chapter
\chapter{Tecnologie utilizzate}
TODO


% Tool description chapter
\chapter{Descrizione del tool}
TODO


% Conclusion and future works chapter
\chapter{Conclusioni e lavori futuri}
TODO


\end{document}