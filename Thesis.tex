% Setup and import
\documentclass[12pt,a4paper]{report}
\usepackage[english, italian]{babel}
\usepackage{csquotes}
\usepackage[dvipsnames]{xcolor}
\usepackage{newlfont}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{biblatex}
\usepackage{forest}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{listings}
\usepackage{tikz}
\textwidth=450pt\oddsidemargin=0pt

% Dedication template
\newenvironment{dedication}
{
    \clearpage            % we want a new page
    \thispagestyle{empty} % no header and footer
    \vspace*{\stretch{1}} % some space at the top
    \itshape              % the text is in italics
    \raggedleft           % flush to the right margin
}
{
    \par                  % end the paragraph
    \vspace{\stretch{3}}  % space at bottom is three times that at the top
    \clearpage            % finish off the page
}

% Project Tree definition
\definecolor{folderbg}{RGB}{124,166,198}
\definecolor{folderborder}{RGB}{110,144,169}

\tikzset{
  folder/.pic={
    \filldraw[draw=folderborder,top color=folderbg!50,bottom color=folderbg]
      (-1.05*4pt,0.24pt+5pt) rectangle ++(.75*4pt,-0.24pt-5pt);  
    \filldraw[draw=folderborder,top color=folderbg!50,bottom color=folderbg]
      (-1.15*4pt,-4pt) rectangle (1.15*4pt,4pt);
  }
}

% Definition init
\newtheorem{definition}{Definition}[chapter]
\newtheorem{remark}{Remark}[definition]

% Setup algorithm numeration to follow the definition and remark ones
\renewcommand{\thealgorithm}{\arabic{chapter}.\arabic{algorithm}}

% Setup listings code style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{White},
    numberstyle=\tiny\color{Gray},
    commentstyle=\color{OliveGreen},
    keywordstyle=\color{MidnightBlue},
    stringstyle=\color{OrangeRed},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=false,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}


% ForEach construct definition
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

% Tikz submodule import
\usetikzlibrary{automata, positioning, arrows}

\addbibresource{Bibliography.bib}

% Document start 
\begin{document}


% Title page
\begin{titlepage}
    \begin{center}
        {{\Large{\textsc{Alma Mater Studiorum $\cdot$ Universit\`a di
                            Bologna}}}} \rule[0.1cm]{15.8cm}{0.1mm}
        \rule[0.5cm]{15.8cm}{0.6mm}
        {\small{\bf SCUOLA DI SCIENZE\\
                Corso di Laurea in Informatica }}
    \end{center}
    \vspace{15mm}
    \begin{center}
        {\LARGE{\bf Choreia: A Static Analyzer }}\\
        \vspace{3mm}
        {\LARGE{\bf to Generate Choreography Automata}}\\
        \vspace{3mm}
        {\LARGE{\bf from Go Source Code}}\\
    \end{center}
    \vspace{40mm}
    \par
    \noindent
    \begin{minipage}[t]{0.47\textwidth}
        {\large{\bf Relatore:\\
                Prof. Ivan Lanese}}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.47\textwidth}\raggedleft
        {\large{\bf Presentata da:\\
                Enea Guidi}}
    \end{minipage}
    \vspace{20mm}
    \begin{center}
        {\large{\bf Sessione III\\
                Anno Accademico 2020/2021 }}
    \end{center}
\end{titlepage}


% Dedication page
\begin{dedication}
    Alla mia famiglia e agli amici che\\
    mi hanno accompagnato in questo viaggio
\end{dedication}


% Abstract
\begin{abstract}
    Le coreografie sono un paradigma emergente per la descrizione dei sistemi concorrenti che sta prendendo piede negli ultimi anni. Lo scopo principale è quello di fornire al programmatore uno strumento che permetta di capire in maniera immediata la \emph{coreografia} dei partecipanti all'interno del sistema e come questi interagiscono tra loro. Partendo dai singoli partecipanti, e le loro \emph{viste locali}, è possibile ricomporre in maniera bottom-up l'intera Choreography (o \emph{vista globale}) del sistema.
    Un ulteriore vantaggio delle Choreographies è che, quando rispettano alcune proprietà definite, danno garanzie sull'assenza di tipici problemi di concorrenza quali Deadlocks, Liveness e Race Conditions.
    Esistono vari modelli formali di Choreographies, questa tesi tratta nello specifico i \emph{Choreography Automata}, basati su \emph{Finite State Automata} (FSA).
    In questa tesi viene presentato Choreia: un tool di analisi statica che, partendo da un codice sorgente Go, ricava il Choreography Automata del sistema concorrente in maniera bottom-up.
\end{abstract}

% Auto-generated table of contents
\tableofcontents

% Introduction chapter
\chapter{Introduzione}
Negli ultimi anni si è visto un progressivo aumento nell'utilizzo di \emph{sistemi distribuiti} e delle cosidette \emph{architetture orientate ai microservizi} così come un rinnovato interesse verso lo sviluppo concorrente.\bigskip \\
Questo nuovo interesse ha portato cambiamenti  e trasformato i linguaggi di programmazione e il \emph{language design}, si è cercato infatti di venire incontro alle richieste dei programmatori per quanto riguarda l'approccio del linguaggio alla concorrenza. Ricordiamo infatti che alcuni linguaggi non offrivano funzionalità native o talvolta le API fornite erano troppo complicate ed intricate per garantirne un utilizzo chiaro. In generale la concorrenza era un \emph{afterthought}. Alcuni esempi pratici di queste trasformazioni possono essere visti in nuovi linguaggi di programmazione come Go ed Elixir che offrono un'approccio semplificato e più chiaro alla concorrenza ma anche in linguaggi più consolidati come C++, che con lo standard 20 ha introdotto construtti che facilitano l'utilizzo rispetto alle implementazioni precedenti.\\
Tuttavia sviluppare è estremamente complesso sviluppare un sistema concorrente (o distribuito) esente da errori, allo stesso modo si presentano varie problematiche legate al \emph{debugging} dello stesso, in entrambi i casi si fatica a riprodurre il bug o a testare tutte le casiste possibili. Questo aspetto di difficoltà è intrinsicamente legato alla natura non deterministica di un sistema concorrente. Inoltre questi problemi di riproducibilità e validazioni crescono esponenzialmente in difficoltà al crescere della complessità del sistema stesso.\bigskip \\
Da queste probllematiche nasce dunque la necessità di avere strumenti che aiutino lo sviluppatore, per questo motivo parallelamente al trend sopra descritto, sono stati proposti nuovi \emph{paradigmi} e \emph{modelli teorici} che mirano ad esemplificare la scrittura di programmi concorrenti, tra questi troviamo le \emph{Choreographies}.\\
L'idea alla base delle coreografie è la seguente: definire le interazioni tra due o più processi durante l'esecuzione. Le coreografie forniscono al programmatore la possibilità di osservare e analizzare le interazioni che avvengono tra i partecipanti alla stessa ed allo stesso modo possono fornire uno strumento per la descrizione delle stesse durante la fase progettuale.\bigskip \\
Tipicamente nelle coreografie i proocessi comunicano tra loro attraverso \emph{message pasing}, avremo quindi una primitiva del tipo:
\begin{center}
    $Alice \rightarrow Bob : message$
\end{center}
per indicare specificare che Alice sta inviando un messaggio a Bob. La caratteristica che distingue le Coreografie dagli altri paradigmi consiste nel fatto che quest'ultime forniscono 2 tipi di \emph{view} diverse:
\begin{itemize}
    \item \textbf{View globale}: È una descrizione dal punto di visto \emph{olistico}
    \item \textbf{View locale}: È una descrizione di un singolo componente \emph{in isolamento}
\end{itemize}
È sempre possibile, partendo dalla global views, ottenere una sua local view attraverso l'operazione di \emph{proiezione} ed è anche possibile unire più global view insieme mediante l'operazione di \emph{composizione}. Oltre a queste operazioni una coreografia che soddisfa certe proprietà ed è dunque \emph{ben formata} permette dii fare assunzioni riguardo all'assenza dei classici problemi di programmazione concorrente come \emph{deadlocks}, \emph{race conditions}, ecc fornendo al programmatore uno strumento di verifica per il suo codice.\bigskip \\
In questa tesi viene presentato \emph{Choreia}, un tool di analisi statica che permette di ricavare da del codice sorgente Go il Choregraphy Automata associato. I Choreography Automata sono un \emph{modello} per descrivere le coreografie basato su \emph{automi a stati finiti (FSA)}, un particolare vantaggio dei Choreography Automata è la ppossibilità di poter riutilizzare tutta le nozioni teoriche già esistente in letteratura sugli automi a stati finiti. Verrano introdotte anche le \emph{Communicating Finite State Machine} per la descrizione delle local views oltre agli algoritmi di poriezione e composizione. Inoltre verrà presentato un algoritmo per la composizione di multiple local views in una unica global view, derivato dall'algoritmo di composizone tra global views. 


\iffalse
    Negli ultimi anni si è visto un interesse sempre più pronunciato verso lo sviluppo di sistemi concorrenti e distribuiti, questo si riflette nella progettazione a microservizi o in linguaggi di programmazione più recenti come Go, Rust o C++ 20 i quali implementano tutti, in forme disparate, un approccio alla concorrenza facilitato e univoco evitando la complessità e frammentazione che può derivare dall'utilizzo di librerie esterne e non standardizzate.\\
    % ? Keep this paragraph
    Prendendo per esempio Go, talvolta chiamato anche golang, un linguaggio di programmazione creato nel 2009 da Robert Griesemer, Rob Pike e Ken Thompson, che negli anni successivi prende una forte trazione, fino a essere supportato da Google, sopratutto nel settore del web-development e system programming. Alcuni dei fattori da successo sono una compilazione ed esecuzione veloce, una grammatica semplice e snella e un approccio \emph{built-in} alla concorrenza con tipi e primitive fornite direttamente dalla standard library. Quest'ultima infatti fornisce un solo tipo di dato \emph{chan} che può essere \emph{buffered} o \emph{unbuffered}, la comunicazione che avviene su questi canali è rispettivamente asincrona e sincrona.\\
    Parallelamente a questo rinnovato interesse verso la programmazione concorrente e distribuita nasce l'esigenza di formalizzare dei modelli teorici che possano supportare la progettazione, gestione e manutenzione di sistemi concorrenti. Uno di questi modelli sono le \emph{Choreographies}, le quali facilitano la rappresentazione e descrizione di sistemi concorrenti in cui i singoli \emph{attori} comunicano tra di loro. Un aspetto distintivo delle Choreographies è la coesistenza di due \emph{view}:
    \begin{itemize}
        \item Vista \textbf{globale}: descrive la coordinazione necessaria tra i componenti di un sistema
        \item Vista \textbf{locale}: descrive il comportamento di un singolo componente \emph{in isolamento}
    \end{itemize}
    % ? Add the parts about Choreography Automatas properties and how them can help making assumption on the Go program
    L'obiettivo di questa tesi è quello di progettare e implementare un tool che permetta, preso un sorgente Go e per mezzo di analisi statica, di estrarre un Choreography Automata, ovvero un automa a stati finiti che rappresenta la Choreography in modo grafico, più chiaro e immediato rispetto alla lettura del codice sorgente.
\fi


% "Preliminaries and Notation" chapter
\input{Chapters/Preliminaries.tex}

% "Technology stack" chapter
\input{Chapters/Technologies.tex}

% "Changes and adaptations" chapter
\input{Chapters/Adaptations.tex}

% "Tool description" chapter
\input{Chapters/Tool.tex}

% "Conclusion and future works" chapter
\input{Chapters/Conclusions.tex}


\printbibliography


\end{document}