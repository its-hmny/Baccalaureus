% Preliminaries and Notation chapter
\chapter{Nozioni preliminari e notazione}
\label{cap:Preliminaries}
% Finite State Automata (+ related) section
\section{FSA non deterministici e deterministici}
Prima di introdurre le coreografie e i Choreography Automata è necessario fare un breve richiamo di alcune nozioni fondamentali quali la nozione di Automa a Stati Finiti (FSA)\cite{Linguaggi_di_Prorgammazione} e alcune operazioni possibili sugli stesssi.
Gli automi a stati finiti sono la descrizione di un sistema dinamico che si evolve nel tempo, esiste un parallelo tra gli automi e i calcolatori moderni, per esempio il flusso d'esecuzione di un programma può essere rappresentato attraverso un automa.
Alcune applicazioni pratiche di questi automi possono essere, per esempio, regular expression (RegEx o RegExp), lexer e parser ma possono essere impiegati, come vedremo in questa tesi, anche nel campo dei sistemi concorrenti.\\
Si noti che sebbene per gli scopi di questa tesi gli automi a stati finiti siano dei costrutti sufficentemente potenti esistono tuttavia altre classi di automi, espressivamente più potenti, ai quali corrispondo altrettante classi di linguaggi (si veda, per esempio, gli automi a pila) tuttavia gli automi appartenenti a questa classe sono tra i più semplici e immediati.

\begin{definition}[Finite State Automata]
    Un automa a stati finiti (FSA) è una tupla A = $\langle \mathcal{S}, s_0, \mathcal{F}, \mathcal{L}, \delta \rangle$ dove:
    \begin{itemize}
        \item $\mathcal{S}$ è un insieme finito di stati
        \item $s_0 \in \mathcal{S}$ è lo stato iniziale dell'automa
        \item $\mathcal{F}$ è l'insieme degli stati finali o di accettazione ($\mathcal{F} \subseteq \mathcal{S}$)
        \item $\mathcal{L}$ è l'alfabeto finito, talvolta detto anche insieme di label ($\epsilon \notin \mathcal{L}$)
        \item $\delta : \mathcal{S} \times (L \cup \{\epsilon\}) \rightarrow \mathcal{P}(\mathcal{S})$ è la funzione di transizione ($\epsilon$ denota la stringa vuota)
    \end{itemize}
\end{definition}

\begin{remark}
    Tipicamente è solito trovare una definizione in cui è presente anche l'insieme degli stati di terminazione (o di accettazione) $\mathcal{F}$. In questo caso non è stato definito e pertanto assumiamo che ogni $s \in \mathcal{S}$ sia uno stato di accettazione.
\end{remark}

\begin{remark}
    Va notato anche che questa definizione coincide con quella di automa a stati finiti \emph{non deterministico}, solitamente indicato in letteratura con la sigla NFA (\emph{Non Deterministic Finite Automata}). Una sottoclasse particolarmente rilevante è quella dei DFA (\emph{Deterministic Finite Automata}) che andremo a definire di seguito.
\end{remark}

\begin{definition}[Deterministic Finite Automata]
    Un automa a stati finiti deterministico è una tupla D = $\langle \mathcal{S}, s_0, \mathcal{F}, \mathcal{L}, \delta \rangle$ dove $\delta : \mathcal{S} \times L \rightarrow \mathcal{S}$
\end{definition}
Le varianti deterministiche si distinguono dalle loro controparti non deterministiche dal fatto che non ammettono ne l'utilizzo di $\epsilon$ transizioni, ne l'utilizzo di transizioni \emph{uscenti}, dallo stesso stato, con la medesima etichetta. Sebbene queste due varianti siano tra loro equivalenti, l'utilizzo di una variante rispetto all'altra può essere determinato da fattori come: necessità di una maggiore elasticità (gli NFA sono meno stringenti rispetto ai DFA) o di una migliore chiarezza (i DFA sono più immediati e semplici).\\
In ogni caso è sempre possibile, dato un NFA qualunque, ottenere un DFA ad esso equivalente anche se quest'ultimo spesso ha un numero maggiore di stati rispetto all' NFA di partenza. L'algoritmo che permette di fare questa trasformazione fa uso estensivo di \emph{$\epsilon$ closure}\cite{Linguaggi_di_Prorgammazione} e della funione \emph{mossa}\cite{Linguaggi_di_Prorgammazione} che andremo a definire di seguito:

\begin{definition}[$\epsilon$ closure]
    Fissato un NFA N = $\langle \mathcal{S}, s_0, \mathcal{F}, \mathcal{L}, \delta \rangle$ ed uno stato $s \in \mathcal{S}$ si dice $\epsilon$ closure di s, indicata con $\epsilon$-clos(s), il più piccolo $\mathcal{R} \subseteq \mathcal{S}$ tale che:
    \begin{itemize}
        \item $s \in \epsilon$-clos(s)
        \item se x $\in \epsilon$-clos(s) allora $\delta(x, \epsilon) \subseteq \epsilon$-clos(s)
    \end{itemize}
\end{definition}

\begin{remark}
    Se $\mathcal{X}$ è un insieme di stati definiamo $\epsilon$-clos($\mathcal{X}$) come $\bigcup_{x \in \mathcal{X}} \epsilon \mbox{-clos(x)}$.
\end{remark}

\begin{definition}[Mossa]
    Dato un insieme di stati $\mathcal{X} \subseteq \mathcal{S}$ e un simbolo $\alpha \in \mathcal{L}$ definiamo la funzione \emph{mossa}: $\mathcal{P(S)} \times \mathcal{L} \longrightarrow \mathcal{P(S)}$ tale che: \emph{mossa}$(\mathcal{X}, \alpha) = \bigcup_{x \in \mathcal{X}}\delta(x, \alpha)$, ovvero l'insieme di stati raggiungibili da un dato insieme di stati di partenza, leggendo in input $\alpha$.
\end{definition}
\newpage % ! Avoid forcefully break page
L'algoritmo che permette di ricavare un DFA da un qualsiasi NFA è il seguente:
\begin{algorithm}
    \caption{Costruzione per sottoinsiemi}\label{alg:SubsetConstruction_Algorithm}
    \begin{algorithmic}
        \State $x \gets$ $\epsilon$-clos($s_0$) \Comment{Lo stato iniziale del DFA}
        \State $\mathcal{T} \gets \{ x \}$                   \Comment{Un insieme di $\epsilon$-clos}
        \While{$\exists$ t $\in \mathcal{T}$ non marcato}
        \State marca(t)
        \ForEach {$\alpha \in \mathcal{L} $}
        \State $r \gets \epsilon$-clos(mossa(t, $\alpha$))
        \If {$r \notin \mathcal{T}$}
        \State $\mathcal{T} \gets \mathcal{T} \cup \{r\}$
        \EndIf
        \State $\delta(t, \alpha) \gets r$  \Comment{Denota che la $\delta$ del DFA con input t ed $\alpha$ darà output r}
        \EndFor
        \EndWhile
    \end{algorithmic}
\end{algorithm}\\
Si noti che $x$, $\mathcal{T}$ e $\delta$ saranno rispettivamente lo stato iniziale, l'insieme degli stati e la funzione di transizione del DFA corrispondente, $\mathcal{F}$ sarà invece l'insieme di tutti i $t \in \mathcal{T}$ che al loro interno contengono almeno uno stato finale dell'NFA di partenza mentre $\mathcal{L}$ rimane invariato. Quindi il DFA ottenuto in output sarà D = $\langle \mathcal{T}, x, \mathcal{F}, \mathcal{L}, \delta \rangle$.

\subsection{Minimizzazione}
Nell'ambito della teoria degli automi esistono una serie di operazioni e trasformazioni che è possibile effettuare, per esempio la composizione di più automi, tuttavia nel nostro caso poniamo particolare riguardo alla minimizzazzione. Capita spesso infatti che un automa abbia un numero di stati maggiore del necessario e che alcuni di questi stati siano equivalenti tra loro (e dunque duplicati). Attraverso la minimizzazione è possibile \emph{fondere} insieme questi stati tra loro ottenendo infine un automa più snello (in numero di stati e transizioni) e più facile da comprendere. Si noti questo problema degli stati duplicati non sorge solo dalla progettazione umana ma può anche essere un \emph{side effect} di algoritmi come quello di Costruzione per sottoinsiemi mostrato sopra.\\
L'algoritmo più conosciuto per minimizzare un automa è detto \emph{Algoritmo di Riempimento a Scala}\cite{Linguaggi_di_Prorgammazione} e, di seguito, vedremo il suo funzionamento. Tuttavia occorre fare un'importante premessa prima di introdurre l'algoritmo, il funzionamento dello stesso è legato al fatto che la funzione di transizione $\delta$ sia definita su ogni $\alpha \in \mathcal{L}$, la lettereatura distingue gli automi \emph{incompleti}, che non verificano questa condizione, da quelli \emph{completi}.\\
Negli automi incompleti la funzione di transizione è parziale e dunque sorgono dei problemi nel momento in cui cerchiamo di minimizzarli, una soluzione molto semplice è quella di usare uno \emph{stato di errore} (detto anche \emph{stato pozzo}). Essenzialmente si va a completare la funzione di transizione nei casi mancanti (non definiti) con una transizione verso questo stato d'errore, allo stesso tempo tutte le transizioni uscenti da questo stato di errore tornano sullo stesso ($\forall_{ \alpha \in \mathcal{L}} \delta(E, \alpha) = E$) il nome di stato di pozzo deriva infatti dal fatto che una volta raggiunto non è possibile uscirne.\\
L'intuizione alla base dell'algoritmo di riempimento a scala è la seguente, valutiamo le singole coppie $(p, q)$ con $p, q \in \mathcal{S}$ e cerchiamo un $\alpha \in \mathcal{L}$ tale che lo stato p si comporti diversamente rispetto allo stato q, questo ci permette di dimostrare che p e q non sono equivalenti e dunque non hanno ragione di essere fusi insieme. Alla fine dell'esecuzione tutte le coppie di stati che non saranno distinte tra loro indicheranno degli stati equivalenti.\\
L'algoritmo di Riempimento della Tabella a Scala è definito come segue:
\begin{algorithm}
    \caption{Riempimento della Tabella a Scala}\label{alg:Minimization_Algorithm}
    \begin{algorithmic}
        \State Inizializza la tabella a scala con le coppie (p,q)
        \State Marca le coppie (x,y) con marca $x_0$ con $x \in \mathcal{F}$ e $y \notin \mathcal{F}$
        \While{$\exists$ almeno un marchio $x_i$ all'iterazione i}
        \If{$\exists \alpha \in \mathcal{L}, \exists p, q \in \mathcal{S}$ tale che $\delta(p, \alpha) \neq \delta(q, \alpha)$}
        \State Marca (p, q) con marca $x_i$
        \EndIf
        \State Considera all'iterazione seguente solo gli stati non marcati
        \EndWhile
    \end{algorithmic}
\end{algorithm}

\subsection{Esempi}
Per concludere questa sezione mostriamo di seguito esempi dei vari concetti definiti in precedenza. Il seguente è un NFA N un grado di riconoscere la Regular Expression $(a|b)^*ba$:
\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[->,>=stealth',node distance=2cm,scale=1, transform shape]
        \node[state,initial] (q0) {$q_0$};
        \node[state] (q1) [right of=q0] {$q_1$};
        \node[state] (q2) [above right of=q1] {$q_2$};
        \node[state] (q3) [right of=q2] {$q_3$};
        \node[state] (q4) [below right of=q1] {$q_4$};
        \node[state] (q5) [right of=q4] {$q_5$};
        \node[state] (q6) [above right of=q5] {$q_6$};
        \node[state] (q7) [right of=q6] {$q_7$};
        \node[state] (q8) [right of=q7] {$q_8$};
        \node[state, accepting] (q9) [right of=q8] {$q_9$};
        \draw
        (q0) edge[above] node{$\epsilon$} (q1)
        (q0) edge[bend left=60, above] node{$\epsilon$} (q7)
        (q1) edge[above] node{$\epsilon$} (q2)
        (q2) edge[above] node{$a$} (q3)
        (q3) edge[above] node{$\epsilon$} (q6)
        (q1) edge[above] node{$\epsilon$} (q4)
        (q4) edge[above] node{$b$} (q5)
        (q5) edge[above] node{$\epsilon$} (q6)
        (q6) edge[above] node{$\epsilon$} (q7)
        (q6) edge[above] node{$\epsilon$} (q1)
        (q7) edge[above] node{$b$} (q8)
        (q8) edge[above] node{$a$} (q9);
    \end{tikzpicture}
    \caption{Un possibile NFA che riconosce la RegEx $(a|b)^*ba$}
    \label{fig:NonDeterministic_Example}
\end{figure}\\
Si noti che questo è solo un \emph{possibile} NFA in grado di riconscere il linguaggio dato ma ne esistono infiniti altri equivalenti ad esso. Vediamo ora invece il DFA D, equivalente ad N, calcolato tramite l'algorimo di \emph{Costruzione per sottoinsiemi}
\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,scale=1, transform shape, baseline=0]
        \node[state,initial] (A) {$A$};
        \node[state] (B) [above right of=A] {$B$};
        \node[state] (C) [right of=A] {$C$};
        \node[state, accepting] (D) [above right of=C] {$D$};
        \draw
        (A) edge[above] node{$a$} (B)
        (A) edge[above] node{$b$} (C)
        (B) edge[loop above] node{$a$} (B)
        (B) edge[above] node{$b$} (C)
        (C) edge[loop below] node{$b$} (C)
        (C) edge[bend right, above] node{$a$} (D)
        (D) edge[above] node{$a$} (B)
        (D) edge[bend right,above] node{$b$} (C);
    \end{tikzpicture}
    \parbox{5cm}{
        \begin{tabular}{c c}
            Stati NFA           & Stati DFA \\
            \{ 0,1,2,4,7 \}     & A         \\
            \{ 1,2,3,4,6,7 \}   & B         \\
            \{ 1,2,4,5,6,7,8 \} & C         \\
            \{ 1,2,3,4,6,7,9 \} & D
        \end{tabular}
    }
    \caption{Il DFA equivalente a quello in figura \ref{fig:NonDeterministic_Example}}
    \label{fig:Deterministic_Example}
\end{figure}\\
Ora andiamo a minimizzare il DFA ottenuto precedentemente rimuovendo gli stati equivalenti tramite l'algoritmo di \emph{Riempimento della Tabella a Scala}
\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,scale=1, transform shape, baseline=0]
        \node[state,initial] (AB) {$A,B$};
        \node[state] (C) [right of=A] {$C$};
        \node[state, accepting] (D) [right of=C] {$D$};
        \draw
        (AB) edge[loop above] node{$a$} (AB)
        (AB) edge[above] node{$b$} (C)
        (C) edge[loop above] node{$b$} (C)
        (C) edge[bend left, above] node{$a$} (D)
        (D) edge[bend left, above] node{$b$} (C)
        (D) edge[bend left, below] node{$b$} (A);
    \end{tikzpicture}
    \space \space \space
    \parbox{5cm}{
        \begin{tabular}{ | c | c | c | c |}
            \hline B &       & $//$  & $//$  \\
            \hline C & $x_1$ & $x_1$ & $//$  \\
            \hline D & $x_0$ & $x_0$ & $x_0$ \\
            \hline   & A     & B     & C     \\
            \hline
        \end{tabular}
    }
    \caption{Il DFA minimizzato ottenuto da quello in figura \ref{fig:Deterministic_Example}}
    \label{fig:Minimization_Example}
\end{figure}

\section{Choreography Automata}
Passiamo ora alla definizione dei \emph{Choreography Automata} (CA); iniziamo diversificando la nozione di \emph{coreografia} e \emph{Choreography Automata}\cite{Choreography_Automata} il primo è un modello logico che permette di specificare le interazioni tra più attori (siano essi processi, programmi, etc.) all'interno di un sistema (concorrente nel nostro caso) mentre i secondi sono invece un'\emph{istanza} possibile per questo modello. In questo caso noi stiamo scegliendo di rappresentare le coreografie tramite degli Automi a Stati Finiti ma questo non esclude altre possibili realizzazioni.\\
Per prima cosa ricordiamo che le coreografie hanno due tipologie di \emph{view} possibili:
\begin{itemize}
    \item \textbf{Global View}: Che descrive il comportamento dei \emph{partecipanti} "as a whole" specificando anche come questi interagiscano tra loro.
    \item \textbf{Local View}: Che descrive il comportamento di un singolo partecipante in \emph{isolamento} rispetto agli altri.
\end{itemize}
La \emph{scelta implementativa} di utilizzare gli FSA è dovuta al fatto che gli stessi, oltre ad essere semplici ma espressivi, permettono di utilizzare loop "nested" ed "entangled" e permettono di sfruttare in maniera molto conveniente i risultati e le nozioni descritti in precedenza. I Choreography Automata sono dunque dei \emph{casi particolari} di automi a stati finiti in cui le transizioni specificano le interazioni tra i vari partecipanti della coreografia.\\
Un esempio di Choreography Automata è visibile nella figura sottostante, la sintassi delle label sulle transizioni è la seguente: \emph{sender}$\rightarrow$\emph{receiver}:\emph{message}.
\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.7cm,scale=1, transform shape]
        \node[state,initial] (q0) {$q_0$};
        \node[state] (q1) [right of=q0] {$q_1$};
        \node[state] (q2) [right of=q1] {$q_2$};
        \draw
        (q0) edge[above] node{$A \rightarrow B: tic$} (q1)
        (q1) edge[above] node{$B \rightarrow C: count$} (q2)
        (q2) edge[bend left,above] node[below]{$C \rightarrow A: toc$} (q0);
    \end{tikzpicture}
    \caption{Un esempio di Choreogaphy Automata}
    \label{fig:ChoreographyAutomata_Example}
\end{figure}\\
In questo caso sono rappresentate le interazioni tra gli attori A,B e C, in particolare: A inizia la comunicazione mandando un messaggio \emph{tic} a B, B (dopo aver ricevuto tale messaggio) invia a sua volta \emph{count} a C ed infine C risponde ad A con messaggio \emph{toc}.

\begin{definition}[Choreography Automata]
    \label{def:Choreography_Automata}
    Un Choreography Automata (c-automata) è un $\epsilon$-free FSA con un insieme di label $\mathcal{L}_{int} = \{ A \rightarrow B : m | A \neq B \in \mathcal{P}, m \in \mathcal{M} \}$ dove:
    \begin{itemize}
        \item $\mathcal{P}$ è l'insieme dei partecipanti (per esempio A, B, ecc)
        \item $\mathcal{M}$ è l'insieme dei messaggi che possono essere scambiati (m, n, ecc)
    \end{itemize}
\end{definition}
\begin{remark}
    Anche se nella definizione non sono ammesse $\epsilon$-transizioni una variante non deterministica rimane sempre possibile, come vedremo anche più avanti in questo lavoro.
\end{remark}

\subsection{CFSM e Local Views}
Ora che abbiamo una definizione formale dei Choreography Automata, possiamo concentrarci sull'estrapolazione delle varie view locali a partire dallo stesso. Ricordiamo che le view locali descrivono il comportamento di un singolo partecipante all'interno della coreografia e che sono ottenute attraverso un operazione di \emph{proiezione} applicata all'intera coreografia (la view globale). Prima di definire però questa operazione di proiezione serve introdurre il concetto di \emph{Communicating Finite-State Machine (CFSM)}. Come il nome suggerisce questo è sempre un modello basato su automi a stati finiti usato specificatamente per la descrizione delle local views. La principale differenza rispetto ai Choreography Automata sta nel fatto che le label sono \emph{direzionali}, ovvero possono essere del tipo "A B ? m" o "A B ! m" per indicare che A riceve (rispettivamente invia) un messaggio m a B.

\begin{definition}[Communicating Finite-State Machine]
    \label{def:CommunicatingFiniteStateMachine}
    Una Communicating Finite State Machine (CFSM) è un FSA $C$ con insieme di labels:
    \\ \\
    \centerline{$\mathcal{L}_{act} = \{$A B ! m, A B ? m $|$ A, B $ \in \mathcal{P},$ m $ \in \mathcal{M}\}$}
    \\ \\
    dove $\mathcal{P}$ e $\mathcal{M}$ sono definiti come in precedenza.
\end{definition}
Dunque il \emph{soggetto} di un'azione in input "A B ? m" è A, lo stesso vale per l'azione di output "A B ! m", indichiamo quindi con $M_a$ la CFSM che ha solo transizioni con soggetto A. Si noti che esiste ed è possibile definire formalmente una funzione \emph{projection} che assegna ad ogni partecipante $p \in \mathcal{P}$ la sua relativa CFSM $M_p$.\\
Ora che abbiamo introdotto tutti i concetti necessari possiamo definire di seguito l'operazione di \emph{Proiezione} su Choreography Automata. \\
Definiamo brevemente la notazione $s_1 \xrightarrow{a} s_{2}$ come abbreviazione per indicare che esiste una transizione da $s_1$ a $s_2$ con label a, formalmente $\exists a \in \mathcal{L}_{act}, s_1, s_2 \in \mathcal{S}. \delta(s_1, a) = s_2$.

\begin{definition}[Proiezione]
    La proiezione su A di una transizione $t = s_1$ $\xrightarrow{a}$ $s_2$ di un Choreography Automata, scritta $t\downarrow_{A}$ è definita come:
    \begin{equation*}
        t \downarrow_{A} =
        \begin{cases}
            s \xrightarrow{\text{A C ! m}} s' & $se $ a = B \rightarrow C : m \wedge B = A       \\
            s \xrightarrow{\text{B A ? m}} s' & $se $ a = B \rightarrow C : m \wedge C = A       \\
            s \xrightarrow{\epsilon} s'       & $se $ a = B \rightarrow C : m \wedge B, C \neq A \\
            s \xrightarrow{\epsilon} s'       & $se $ a = \epsilon
        \end{cases}
    \end{equation*}
\end{definition}
La proiezione di un CA = $\langle \mathcal{S}, s_0, \mathcal{L}_{int}, \delta \rangle$ sul partecipante $p \in \mathcal{P}$, denotata con CA$\downarrow_p$ è ottenuta ricavando in primis l'automa intermedio:
\\ \\
\centerline{$A_p = \langle \mathcal{S}, s_0, \mathcal{L}_{act}, \{ s \xrightarrow{t\downarrow_{p}} s' | s \xrightarrow{t} s' \in \delta \} \rangle$}
\\ \\
Tuttavia, come possiamo vedere nella definizione sopra, questo automa intermedio è nondeterministico. è dunque necessario rimuovere le eventuali $\epsilon$ transizioni, ottenendone una versione deterministica e successivamente minimizzare quest'ultima. Entrambe le operazioni sono le medesime definite rispettivamente negli algoritmi \ref{alg:SubsetConstruction_Algorithm} e \ref{alg:Minimization_Algorithm}

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.7cm,scale=1, transform shape]
        \node[state,initial] (A0) {0};
        \node[state] (A1) [below of=A0] {1,2};

        \node[state,initial] (B0) [right of=A0] {0,2};
        \node[state] (B1) [below of=B0] {1};

        \node[state,initial] (C0) [right of=B0] {0,1};
        \node[state] (C1) [below of=C0] {2};

        \draw
        (A0) edge[bend left, above] node[rotate=270]{AB! tic} (A1)
        (A1) edge[bend left, above] node[rotate=90]{AC? toc} (A0)

        (B0) edge[bend left, above] node[rotate=270]{BA? tic} (B1)
        (B1) edge[bend left, above] node[rotate=90]{BC! count} (B0)

        (C0) edge[bend left, above] node[rotate=270]{BC? count} (C1)
        (C1) edge[bend left, above] node[rotate=90]{CA! toc} (C0);
    \end{tikzpicture}
    \caption{Le tre view locali estratte dall'automa in figura \ref{fig:ChoreographyAutomata_Example}}
    \label{fig:Projection_Example}
\end{figure}