% "Technology stack" chapter
\chapter{Tecnologie e librerie utilizzate}
\section{Go (golang)}
\subsection{Overview}
Go\cite{Go_Wikipedia} (anche chiamato {golang}) è un linguaggio di programmazione \emph{general purpose} open source sviluppato nel 2007 da Robert Griesemer, Rob Pike e Ken Thompson e poi supportato da Google negli anni a seguire. Fortemente ispirato al C presenta una sintassi minimale e molto semplice, Go è \emph{statically typed} e fornisce un \emph{Garbage Collector} lasciando comunque all'utente la possibilità di interagire con i puntatori e allocare dinamicamente la memoria in modo autonomo.\\
Alcuni dei problemi che Go mira a risolvere sono
\begin{itemize}
    \item \textbf{Controllo restrittivo delle dipendenze}: Infatti per evitare di appesantire l'eseguibile finale Go rifiuta di compilare moduli o file dove non tutte le dipendenze importate vengono utilizzate
    \item \textbf{Compilazione più veloce}: Grazie a quanto detto sopra e alla sintassi estremamente semplice e snella il compilatore riesce a diminuire drasticamente il tempo richiesto alla compilazione mantenendo tutti i vantaggi dell'avere le eventuali ottimizzazioni a \emph{compile time}
    \item \textbf{Approccio semplificato alla concorrenza}: Il linguaggio utilizza le Goroutine, dei \emph{processi leggeri}, le quali permettono un approccio semplificato ed accessibile alla programmazione concorrente
\end{itemize}
Altre feature del linguaggio degne di nota sono: il package manager e l'ecosistema di pacchetti totalmente distribuito  e decentralizzato, il numero di moduli e librerie disponibili, e la grande varietà di architetture supportate (comprensive di \emph{microcontroller} e \emph{embedded systems}).\\
Go è stato utilizzato nello sviluppo di tecnologie molto famose e largamente utilizzate come Docker e Kubernetes e attualmente viene regolarmente utilizzato da grandi aziende quali Google, MongoDB, Dropbox, Netflix, Uber e altri.

\subsection{Costrutti di concorrenza}
Come accennato sopra Go fornisce un approccio semplificato e built-in alla concorrenza e alla gestione della stessa, il linguaggio permette di avviare dei processi leggeri chiamati Goroutine e scambiare messaggi tra quest'ultimi tramite l'utilizzo di \emph{canali}, i quali permettono sia comunicazione \emph{sincrona} che \emph{asincrona}.\\
Introduciamo brevemente i principali costrutti di concorrenza messi a disposizione dal linguaggio:
\begin{itemize}
    \item \textbf{Canali}: Go fornisce un tipo di dato built-in \texttt{chan} su cui è possibile fare operazioni di \emph{send} e \emph{receive}, i canali possono essere \emph{buffered} e \emph{unbuffered}, i primi permettono una comunicazione asincrona (fino al riempimento del buffer) mentre i secondi permettono solo comunicazione sincrona.
    \item \textbf{Goroutine}: è possibile far partire delle Goroutine anteponendo la keyword \texttt{go} ad una qualsiasi function call, questa funzione verrà eseguita in un contesto condiviso (si preservano gli \emph{scope} e le variabili locali) ma parallelo rispetto alla Goroutine che l'ha creato.
    \item \textbf{Select}: Un costrutto particolare che permette eseguire operazioni di invio o ricezione su più canali ed eseguire la prima, tra queste operazioni, che non sia bloccante, oltre a questo è possibile definire anche un blocco da eseguire una volta completata suddetta operazione. Opzionalmente è possibile definire un blocco di default che viene eseguito quando nessuna delle operazioni sopra può essere completata in maniera non bloccante.
\end{itemize}
Oltre ai costrutti presentati sopra la \emph{standard library} mette a disposizione altri tipi di dato e costrutti \emph{classici} come \emph{Mutex}, \emph{Semafori}, \emph{Monitor} che tuttavia non verranno trattati in questa tesi.
\newpage % TODO Avoid forcefully break page
\lstinputlisting[language=Go, caption=Esempio di utilizzo dei costrutti di concorrenza forniti da Go]{Snippets/GoConcurrency.go}
\bigskip
Come possiamo vedere in questo esempio: l'esecuzione parte dalla Goroutine \texttt{main} che inizializza i canali \texttt{a} e \texttt{b} e li passa alle Goroutine \texttt{fuzzer}, dopodichè attende di ricevere i vari messaggi da entrambi i canali contemporaneamente fintanto che entrambi non vengano chiusi per poi terminare.

\section{Graphviz e DOT}
Vista la necessità di \emph{rappresentare} in qualche modo il Choreography Automata finale e gli eventuali risultati intermedi si è reso necessario l'utilizzo di un qualche tipo di \emph{meccanismo di serializzazione}. Fortunatamente considerando la somiglianza tra Finite State Automata e Grafi (i secondi sono una generalizzazione dei primi) abbiamo potuto riutilizzare tool e strumenti pensati \emph{principalmente} per quest'ultimi.\\
Abbiamo quindi scelto di usare Graphviz\cite{Graphviz_Wikipedia}, una libreria open source per la visualizzazione di grafi la quale utilizza DOT\cite{DOT_Wikipedia}, un formato specificatamente progettato per la descrizione dei grafi.\\
La scelta è ricaduta su DOT e Graphviz per alcuni motivi principali:
\begin{itemize}
    \item Il linguaggio DOT è \emph{human readable} e particolarmente facile da comprendere, inoltre Graphviz permette di \emph{convertire} o \emph{esportare} in formati di uso più comune come PNG o SVG
    \item Permette un utilizzo combinato con \emph{Corinne}\cite{Corinne},un tool grafico per la visualizzazione e manipolazione dei Choreography Automata
    \item Essendo Graphviz ormai uno standard \emph{de facto} sono presenti librerie e binding che ne permettono l'utilizzo con moltissimi linguaggi di programmazione, tra cui Go
\end{itemize}
Di seguito un mostriamo un esempio banale di Choreography Automata definito attraverso il linguaggio DOT.
\begin{lstlisting}[caption=Rappresentazione in DOT dell'automa in figura \ref{fig:ChoreographyAutomata_Example}]
    digraph DOT_Graph_Example {
        node [shape=circle, fontsize=20]
        edge [length=100, fontcolor=black]
      
        q0 -> q1[label="A->B:tic"];
        q1 -> q2[label="B->C:count"];
        q2 -> q0[label="C->A:toc"];
    }
\end{lstlisting}
Chiaramente i Choreography Automata generati da Choreia non saranno così semplici e immediati, ciononostante dovrebbe essere comunque possibile interagirvi e comprenderli.