% "Conclusion and future works" chapter
\chapter{Conclusioni e lavori futuri}
Complessivamente Choreia soddisfa i requisiti che ci siamo posti e permette di fare quello per cui è stato concepito, tuttavia il tool è un \emph{proof of concept} e dunque ancora grezzo e prototipale. Il tool non è esente da possibili miglioramenti, abbiamo visto infatti che esistono alcuni pattern e costrutti di Go che non sono attualmente supportati così come \emph{edge cases} che portano a problemi non risolvibili con le tecniche adottate attualmente. In ogni caso il tool è open source e distribuito con licenza GPL-3.0 e siamo aperti in futuro a proposte e contribuzioni esterne.\bigskip \\
Alcune delle migliorie principali da apportare nel futuro sono:
\begin{itemize}
    \item \textbf{Migliorare la fase di analisi}: migliorando l'approssimazione degli automi associati alle singole funzioni durante la visita dell'AST possiamo migliorare tutti gli automi successivi che sono generati a partire dagli stessi. Inoltre attualmente è possibile effettuare solo il parsing di singoli file, questo esclude l'utilizzo del tool su casi reali e limita l'utente.
    \item \textbf{Supportare altri costrutti}: abbiamo già spiegato che per i fini di questa tesi non consideriamo altri costrutti di concorrenza forniti dalla standard library di Go come Waitgroup, Lock, etc... tuttavia essendo questi costrutti largamente utilizzati all'interno di progetti \emph{reali} questa \emph{mancanza} limita l'applicabilità del nostro tool ad uno \emph{scenario reale}. Aggiungendo supporto per i costrutti sopracitati potremmo iniziare a confrontare il nostro tool con dei casi d'uso effettivi e reali e delineare un confronto con altri tool simili.
    \item \textbf{Migliorare l'algoritmo di composizione}: l'algoritmo di composizione delle local views è stato introdotto per la prima volta in questa tesi partendo dalla sua controparte per la composizione delle global views \cite{CA_Composition} tuttavia esistono degli \emph{edge cases} in cui l'algoritmo attuale riscontra delle difficoltà e serve dunque valutare questi nuovi aspetti e delineare l'evoluzione futura dello stesso.
    \item \textbf{Performance improvements}: finora il tool è stato utilizzato solo su input relativamente semplici e automi di piccole dimensione, aggiungendo nuove funzionalità e supporto per costrutti più complessi non escludiamo che si possano presentare bottleneck alle performance dovute alla complessità computazionale di certe operazioni.
\end{itemize}
Un obiettivo per il futuro è sicuramente quello di ottenere una versione sufficientemente sofisticata da poter essere messa a confronto con altri tool simili al nostro i quali offrono funzionalità di analisi di sistemi concorrenti generando solitamente report sulla \emph{solidità} dello stesso. Un tool molto interessante sotto questo aspetto e che assomiglia per alcuni aspetti a quanto fatto da noi è Gomela\cite{Gomela}: il tool esattamente come Choreia adotta un approccio bottom-up e considera le singole funzioni come \emph{building blocks} da cui partire. La differenza sta nel fatto che, invece che associare un automa ad ogni funzione, Gomela mappa il flusso d'esecuzione attraverso un \emph{behavioural type language} chiamato Promela\cite{Promela}. Una volta descritto il sistema concorrente tramite Promela, questa descrizione può essere usata da dei \emph{model checker} come Spin\cite{Spin} (Simple Promela Interpreter) che si occupano di verificarne la \emph{correttezza} attraverso la simulazione del sistema concorrente in multipli contesti d'esecuzione.\bigskip \\
Segnaliamo che, al momento della scrittura di questa tesi, è stata rilasciata un versione \emph{non stabile} e \emph{sperimentale} del modulo \texttt{go/ssa}. Questo modulo permette, partendo dall'AST, di estrarre una versione in \emph{Static Single Assignment (SSA) Form}\cite{SSA_Form}, questa \emph{rappresentazione intermedia} è usata dai compilatori e dagli static analyzer in quanto fornisce un \emph{contesto di immutabilità} (ogni variabile viene assegnata esattamente una sola volta) che a sua volta permette di \emph{tracciare} in modo più facile ed efficiente le variabili e i \emph{mutamenti} che queste subiscono durante l'esecuzione come \emph{riassegnamento} e \emph{side-effect}. Inoltre, essendo una rappresentazione intermedia, presenta una grammatica più semplice rispetto all'AST di partenza e può aver subito già alcune ottimizzazioni e \emph{linearizzazioni} durante le fasi precedenti.\\
Una volta rilasciata una versione stabile del modulo \texttt{go/ssa} sarebbe interessante integrarlo all'interno di Choreia al fine di ottenere una migliore approssimazione delle singole funzioni tramite automi a stati finiti, quest'ultimi produrranno a loro volta dei Choreography Automata meglio approssimati.