% "Tool description" chapter
\chapter{Choreia}
Choreia è il tool sviluppato come progetto per questa tesi. Il tool si occupa di tutte le fasi descritte nel capitolo precedente e consente all'utente finale di esportare il Choreogaphy Automata ricavato dal codice sorgente in formato DOT.. È un software \emph{open source} con licenza GPL-3.0 scritto completamente in Go, non richiede alcun tipo di setup se non l'installazione iniziale delle dipendenze. è disponibile al download al seguente url: \url{https://github.com/its-hmny/Choreia}\\

\section{Parametri da linea di comando}
Il tool non ha una GUI in quanto, per gli scopi attuali, non è necessaria: infatti non è stato progettato come un tool di uso comune ma come uno strumento per persone interessate e con un minimo di conoscenza pregressa.\\
In ogni caso è possibile tramite \emph{command line} fornire alcuni parametri e flags per un utilizzo \emph{personalizzato}, i parametri disponibili sono:
\begin{table}[h!]
    \centering
    \begin{tabular}{l l l}
        Breve & Esteso   & Descrizione                                               \\
        -i    & --input  & Il \emph{path} del file .go in input                      \\
        -o    & --output & La directory in cui verranno salvati i file i vari automi \\
        -t    & --trace  & Stampa l'AST sullo \texttt{stdout}                        \\
        -h    & --help   & Mostra un messaggio di aiuto con una breve spiegazione    \\
    \end{tabular}
    \caption{La lista di argomenti da linea di comando  accettati da Choreia}
\end{table}

\section{Struttura del progetto}
Il progetto è strutturato su 3 moduli principali, ognuno con uno specifico compito: Il modulo \texttt{fsa} fornisce un'implementazione per gli automi a stati finiti (implementati attraverso un multigrafo), il modulo \texttt{static analysis} gestisce il parsing (fatto tramite la \emph{standard library} golang) e l'estrazione dei metadati dall'AST ed infine il modulo \texttt{transforms} implementa varie operazioni su FSA come per esempio: determinizzazione e minimizzazione (per FSA generici) o la composizione (per automi associati alle local views). \\
La validazione dei dati e l'orchestrazione delle funzionalità fornite dai vari moduli sono gestite nel \texttt{main} che agisce come entry point del programma.\bigskip \\
\begin{forest}
    for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    inner xsep=7pt,
    edge path={
            \noexpand\path [draw, \forestoption{edge}]
            (!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
        },
    % style for your file node 
    file/.style={edge path={
                    \noexpand\path [draw, \forestoption{edge}]
                    (!u.south west) +(7.5pt,0) |- (.child anchor) \forestoption{edge label};},
            inner xsep=2pt,font=\small\ttfamily
        },
    before typesetting nodes={
            if n=1
                {insert before={[,phantom]}}
                {}
        },
    fit=band,
    before computing xy={l=15pt},
    }
    [Choreia
        [cmd
                [main.go, file]
        ]
        [go.mod, file]
        [go.sum, file]
        [internal
                [fsa
                        [\text{fsa.go, transition.go}, file]
                ]
                [static analysis
                        [\text{branch.go, channel.go, function.go, loop.go, ...}, file]
                ]
                [transforms
                        [\text{extraction.go, minimization.go, composition.go, ...}, file]
                ]
        ]
        [LICENSE, file]
        [README, file]
    ]
\end{forest}

\section{Flusso d'esecuzione}
Il flusso d'esecuzione riprende le quattro macro fasi definite nella sezione \ref{sec:GoOutline}.\bigskip\\
Come prima cosa il file in input viene validato e parsato, generando un AST (queste funzionalità sono fornite dal modulo \texttt{go/ast} della standard library), l'AST viene poi navigato da un \emph{visitor} che si occupa di raccogliere e organizzare i dati in apposite strutture dati. Durante questa fase vengono generati degli automi a stati finiti non deterministici associati ad ogni funzione dichiarata all'interno del file in input, questi NFA descriveranno l'evoluzione della computazione nello scope di funzione.\bigskip\\
Una volta ottenuti gli automi e i metadati si procede con lo step successivo, ovvero ricavare gli automi associati alle Goroutine presenti nel programma. Per fare questo si utilizza l'algoritmo definito in \ref{alg:Local_Views_Extraction} che attraverso l'\emph{inlining} delle chiamate di funzione e la sostituzione dei parametri formali con quelli attuali ricava in maniera ricorsiva degli automi non deterministici che rappresentano il flusso d'esecuzione completo della Goroutine. Come fase finale di questo step gli automi vengono determinizzati e minimizzati tramite gli algoritmi mostrati al capitolo \ref{cap:Preliminaries}.\bigskip\\
L'ultimo step dell'esecuzione è quello di generare la global view a partire dalle view locali (e rispettivi automi), esattamente come detto in \ref{sec:Go_Composition} generiamo l'automa prodotto di tutte le local views e poi eseguiamo l'operazione di sincronizzazione su quest'ultimo, infine esportiamo questo automa \emph{finale} in formato DOT.

\section{Esempi pratici}
Di seguito mostriamo alcuni esempi di programmi Go e il rispettivo Choreography Automata associatogli da Choreia. % TODO add link to Choreia repo /folders

\subsection{Loop determinato su canale}
% TODO add program description notes
TODO add program description notes
\lstinputlisting[language=Go]{Snippets/ForLoop.go}
Di seguito troviamo gli automi delle local views associate rispettivamente alle Goroutine $\texttt{main}_0$ e $\texttt{worker}_1$ ottenuti tramite l'algoritmo di estrazione delle local views. Come si puo' facilmente osservare rispecchiano perfettamente il flusso d'esecuzione descritto dal codice che in questo caso e' particolarmente semplice.\\
Si noti che l'automa della Goroutine $\texttt{worker}_1$ non presenta una transizione del tipo $\rightarrow shared$, come si potrebbe essere indotti a pensare, bensi' la label della transizione e' $  \rightarrow channel$ poiche' l'algoritmo di estrazione gestisce la sostituzione dei parametri formali con quelli attuali.
\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,scale=1, transform shape, baseline=0]
        \node[state,initial] (main0) {$0$};
        \node[state, accepting] (main1)[right of=main0] {$1$};
        \node[state, initial, accepting] (worker0)[right=10cm] {$0$};
        \draw
        (main0) edge node{$\bigtriangleup worker_1$} (main1)
        (main1) edge [loop right] node{$\leftarrow channel$} (main1)
        (worker0) edge [loop right] node{$\rightarrow channel$} (worker0);
    \end{tikzpicture}
\end{figure} \bigskip \\
Il seguente e' invece l'automa associato alla global view ottenuto con l'algoritmo di coomposizione a partire dai due precedenti. Chiaramente in questo caso la sincronizzazione e' banale e avviene sulle sole due transizione di invio e ricezione presenti.
\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4.5cm,scale=1, transform shape, baseline=0]
        \node[state,initial] (0){$0$};
        \node[state, accepting] (1)[right of=0] {$1$};
        \draw
        (0) edge node{$main_0 \bigtriangleup worker_1$} (1)
        (1) edge [loop right] node{$main_0 \leftarrow worker_1$} (1);
    \end{tikzpicture}
\end{figure}

\subsection{Operazioni condizionali con \texttt{select}}
% TODO add program description notes
TODO add program description notes
\lstinputlisting[language=Go]{Snippets/Select.go}
Gli automi associati alle Goroutine $\texttt{main}_0$, $\texttt{responder}_1$, $\texttt{responder}_2$ sono i seguenti. Si noti come viene \emph{mappato} il costrutto \texttt{select} attraverso gli automi, dal momento che il costrutto permette di \emph{valutare} operazioni su piu'canali eseguendo solo la prima tra queste che non sia bloccante nell'automa a stati finiti questo viene mappato come una biforcazione del flusso di esecuzione che poi procede nel suo \emph{sottografo} dando eventualmente la possibilita' di ricongiungersi con gli altri.
\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.5cm,scale=1, transform shape, baseline=0]
        \node[state, initial] (main0) {$0$};
        \node[state] (main1)[right of=main0] {$1$};
        \node[state] (main2)[right of=main1] {$2$};
        \node[state] (main3)[right of=main2, above=0.3cm] {$3$};
        \node[state, accepting] (main4)[right of=main3] {$4$};
        \node[state] (main5)[right of=main2, below=0.3cm] {$5$};
        \node[state, accepting] (main6)[right of=main5] {$6$};

        \node[state, initial] (responder10)[below of=main0, right=1cm] {$0$};
        \node[state] (responder11)[right of=responder10] {$1$};

        \node[state, initial] (responder20)[right of=responder11] {$0$};
        \node[state] (responder21)[right of=responder20] {$1$};
        \draw
        (main0) edge node{$\bigtriangleup responder_1$} (main1)
        (main1) edge node{$\bigtriangleup responder_2$} (main2)
        (main2) edge node[rotate=13, above]{$\leftarrow chanA$} (main3)
        (main3) edge node{$\leftarrow chanB$} (main4)
        (main2) edge node[rotate=-13, below]{$\leftarrow chanB$} (main5)
        (main5) edge node{$\leftarrow chanA$} (main6)

        (responder10) edge node{$\rightarrow chanA$} (responder11)

        (responder20) edge node{$\rightarrow chanB$} (responder21)
        ;
    \end{tikzpicture}
\end{figure}\\
Nel Choreography Automaton generato possiamo vedere come in questo caso l'utilizzo del \emph{prodotto tra automi} permette di considerare tutte le possibili evoluzioni del sistema concorrente che poi verrano elaborate ulteriomente e poste nella forma attuale dalla \emph{sincronizzazione}, in questo caso possiamo vedere infatti che la sincronizzazione del genera correttamente entrambi i possibili rami d'esecuzione.\bigskip \\
\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4.8cm,scale=1, transform shape, baseline=0]
        \node[state,initial] (0) {$0$};
        \node[state] (1)[right of=0] {$1$};
        \node[state] (2)[right of=1] {$2$};
        \node[state] (3)[right of=2, above=30pt] {$3$};
        \node[state, accepting] (4)[left of=3, above=30pt] {$4$};
        \node[state] (5)[right of=2, below=30pt] {$5$};
        \node[state, accepting] (6)[left of=5, below=30pt] {$6$};
        \draw
        (0) edge node{$main_0 \bigtriangleup responder_1$} (1)
        (1) edge node{$main_0 \bigtriangleup responder_2$} (2)
        (2) edge node[rotate=18, above]{$main_0 \leftarrow responder_1$} (3)
        (3) edge node[rotate=-18, above]{$main_0 \leftarrow responder_2$} (4)
        (2) edge node[rotate=-18, below]{$main_0 \leftarrow responder_2$} (5)
        (5) edge node[rotate=18, below]{$main_0 \leftarrow responder_1$} (6);
    \end{tikzpicture}
\end{figure}

\subsection{Branching con \texttt{if-then-else}}

\lstinputlisting[language=Go]{Snippets/If-Then-Else.go}

\begin{figure}[h!]
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,scale=1, transform shape, baseline=0]
        \node[state,initial] (0)[below=0.3cm] {$0$};
        \node[state, accepting] (1)[below of=0] {$1$};
        \draw
        (0) edge node{$main_0 \bigtriangleup worker_1$} (1)
        (1) edge [loop right] node{$main_0 \leftarrow worker_1$} (1);
    \end{tikzpicture}
\end{figure}

\subsection{Function call con sostituzione dei parametri}

\lstinputlisting[language=Go]{Snippets/FunctionCall.go}

\begin{figure}[h!]
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,scale=1, transform shape, baseline=0]
        \node[state,initial] (0)[below=0.3cm] {$0$};
        \node[state, accepting] (1)[below of=0] {$1$};
        \draw
        (0) edge node{$main_0 \bigtriangleup worker_1$} (1)
        (1) edge [loop right] node{$main_0 \leftarrow worker_1$} (1);
    \end{tikzpicture}
\end{figure}

