% "Changes and adaptations" chapter
\chapter{Coreografie per Go}
\section{Outline}
L'obiettivo del progetto, ad alto livello, è quello di prendere del codice sorgente \emph{Go} ed estrarre il Choreography Automata che esprima come le Goroutine interagiscono tra loro durante l'esecuzione del programma, in modo da tale da fornire uno strumento allo sviluppatore per \emph{visualizzare} il sistema concorrente.\\
Concettualmente possiamo dividere questo obiettivo in 4 fasi:
\begin{enumerate}
    \item \textbf{Validazione e parsing}: Il codice sorgente viene validato e trasformato in un \emph{Abstact Syntax Tree} (AST).
    \item \textbf{Estrazione dei metadati}: Viene navigato l'AST estraendo tutte le informazioni necessarie (i metadati relativi a funzioni, canali, ecc) e salvandole in strutture dati appropriate.
    \item \textbf{Derivazione delle local views}: Partendo dai metadati si derivano le local views delle varie Goroutine (gli attori del sistema concorrente).
    \item \textbf{Generazione della coreografia}: Dalle local view ottenute, è necessario generare un singolo Choreography Automata che rappresenti l'intera Coreografia del sistema (la view globale).
\end{enumerate}
Questo approccio è chiaramente \emph{Bottom-Up} mentre l'approccio delle definizioni nel capitolo \ref{cap:Preliminaries} è invece \emph{Top-Down}, abbiamo visto infatti come sia possibile, partendo dal Choreography Automata ricavare le singole view locali attraverso l'operazione di \emph{Proiezione}.\\
Come accennato sopra si rende necessaria l'implementazione di un'operazione opposta alla proiezione che permetta di ottenere un view globale a partire dalle sue singole componenti, ovvero le view locali. \\
Il punto cruciale della nostra tecnica è quello di \emph{approssimare} ogni funzione trovata all'interno del codice sorgente in un automa a stati finiti che ne rappresenti il flusso d'esecuzione, in particolare ogni transizione di questo automa rappresenterà un'interazione tra la funzione stessa e il resto della Coreografia. \bigskip \\
Per ragioni di chiarezza e semplicità questa tesi si concentra su un sottoinsieme di Go limitato all'utilizzo di canali, iterazione determinata sugli stessi, \texttt{select} statement, canali passati come argomento tra funzioni e creazione di nuove Goroutine. Altre \emph{feature} del linguaggio come \emph{selector expression}, \emph{anonymous functions}, \emph{high order function} o iterazioni su liste e mappe non sono attualmente supportare e potrebbero dunque causare delle inconsistenze nel Choreography Automata finale. \\
Alcuni esempi di programmi che non sono supportati includono: programmi che utilizzano ricorsione o spawn di Goroutine in ricorsione e programmi che utilizzano collection (liste, mappe o altri tipi di strutture) contenenti canali o iterano sulle stesse. \\

\subsection{Peculiarità di Go}
Per gli scopi di questa tesi è bene considerare le particolarità di Go in modo da adattare il modello teorico allo stesso e \emph{risolvere} le eventuali incongruenze.\bigskip \\
Mentre aspetti tipici di Go come i canali e il costrutto \texttt{select} non generano particolari conflitti con il modello teorico lo stesso non si può dire per le Goroutine: quest'ultime sono intrinsicamente \emph{gerarchiche}, ovvero per ogni programma Go viene avviata sempre e solo una Goroutine (quella che esegue la funzione \texttt{main} e che si comporta come \emph{entry point} del programma stesso) sarà poi questa, durante la sua esecuzione, ad avviarne altre, quest'ultime a loro volta potranno avviarne altre ancora e cosi via.
Il \emph{conflitto} con il modello teorico deriva dal fatto che nella definizione di Choreography Automata si assume in qualche modo che tutti i partecipanti siano già avviati e pronti a comunicare tra loro mentre per i nostri scopi servirebbe tenere traccia della Goroutine \emph{parent} e del momento di avvio della Goroutine in modo da poter definire quando la sua \emph{local view} diventa rilevante nel contesto globale, senza questo ulteriore controllo si potrebbero verificare delle inconsistenze.\bigskip \\
Per fare questo possiamo estendere la definizione di Choreography Automata e di Communicating Finite-State Machine date riespettivamente in \ref{def:Choreography_Automata} e \ref{def:CommunicatingFiniteStateMachine} come segue:

\begin{definition}[Choreography Automata - Estesa]
    Un Choreography Automata (c-automata) è un $\epsilon$-free FSA con un insieme di label:\bigskip \\
    \centerline{$\mathcal{L}_{ext} = \mathcal{L}_{int} \cup \{ A \bigtriangleup B | A, B \in \mathcal{P}\}$} \bigskip \\
    con $\mathcal{L}_{int}$ e $\mathcal{P}$ definiti come in \ref{def:Choreography_Automata} e $\mathcal{M}$ definito come in \ref{subsec:Static_Analysis_Limits}
\end{definition}

\begin{definition}[Communicating Finite-State Machine - Estesa]
    Una Communicating Finite State Machine (CFSM) è un FSA $C$ con insieme di labels:
    \bigskip \\
    \centerline{$\mathcal{L}_{act} = \{$A B ! m, A B ? m, A $\bigtriangleup$ B $|$ A, B $ \in \mathcal{P},$ m $ \in \mathcal{M}\}$}
\end{definition}

\begin{remark}
    Seppur non interessante per gli scopi di questa tesi è possibile adattare la nozione di proiezione in modo che tenga in considerazione di transizione del tipo $A \bigtriangleup B$ con $A, B \in \mathcal{P}$
\end{remark}


\section{Estrazione dei metadati}
Una volta ottenuto un AST valido, serve estrarre i metadati necessari da quest'ultimo. Per gli scopi di questa tesi siamo interessati ad estrarre informazioni sui canali, per esempio: il nome della variabile associata, il \emph{tipo} di messaggi che possono essere scambiati sullo stesso e la tipologia del canale (\emph{buffered} o \emph{unbuffered}) con particolare distinzione tra canali dichiarati nello scope globale e quelli dichiaratie in uno scope locale. Inoltre siamo interessati ad estrarre metadati dalle \emph{function declarations} come: il nome della funzione, canali dichiarati nello scope della stessa e un FSA che rappresenti il flusso d'esecuzione all'interno della funzione stessa (detto Scope Automata). Inoltre vogliamo memorizzare eventuali \emph{parammetri formali} della funzione che richiedono trattamenti particolari come canali o \emph{callback functions}, infatti i canali passati come parametro dal chiamante dovranno poi essere \emph{sostituiti} nel momento in cui la funzione viene chiamata o avviata come Goroutine da un'altra funzione. \bigskip \\
Questa estrazione dei metadati avviene tramite analisi statica, una tecnica di analisi descritta al capitolo \ref{cap:Preliminaries}. Questa tecnica è preferibile rispetto all'analisi dinamica poichè non richiede alcun tipo di esecuzione e quindi protegge da programmi potenzialmente pericolosi e sconosciuti, evita lo scaricamento di eventuali dipendenze per il programma in input e in generale fornisce una visione più ampia e meglio approssimata per i nostri scopi senza richiedere profilazioni multiple. Infatti utilizzando analisi dinamica per questo progetto otterremmo per ogni profilazione eseguita solo un sottografo del Choreography Automata finale che rappresenta il particolare percorso intrapreso dalla Coreografia durante quella esecuzione e non l'intera Coreografia.

\subsection{Limiti dell'analisi statica} \label{subsec:Static_Analysis_Limits}
Anche per questa fase sorge un'inconsistenza con la definizione formale di Choreography Automata data in precedenza: l'insieme $\mathcal{M}$ dei messagi non è determinabile in maniera precisa attraverso l'analisi statica. La definizione \ref{def:Choreography_Automata} sembra suggerire che esista un numero finito e definito di messaggi scambiabili tra i vari attori tuttavia questo insieme non è calcolabile con l'approccio utilizzato.
Ricordiamo infatti che questo tipo di analisi viene effettuata utilizzando solo il codice sorgente e ricavando dei dati senza mai eseguire il codice, in generale non è possibile solo attraverso l'analisi statica ricavare il valore esatto di tutte le variabili (e dunque tutti i messaggi inviati), questo perchè tale valore può essere soggetto a svariati \emph{side effect} durante l'esecuzione o può essere legato a parametri temporali (p.e. timestamp), input forniti dall'utente o altri valori ricavabili solo a runtime. Questi \emph{aspetti} non sono \emph{catturabili} attraverso l'analisi statica e dunque devono essere  gestiti in maniera oppurtuna. \bigskip \\
L'esempio sottostante mostra un caso di possibile di codice sorgente Go in cui l'analisi statica non riesce a catturare i valori effettivi dei vari messaggi scambiati tra i processi: \\
\lstinputlisting[language=Go, caption={Codice sorgente per cui non è possibile calcolare $\mathcal{M}$ tramite analisi statica}, label={lst:DynamicAnalysis}]{Snippets/DynamicAnalysis.go}
\bigskip
Come possiamo vedere il programma mostrato è in realtà alquanto banale: la Goroutine \texttt{main} genera un intero random che poi invia su un canale precedentemente condiviso con le due Goroutine \texttt{worker}, uno dei due processi riceverà questo intero lo incrementerà per poi lo inviarlo nuovamente con un timestamp aggiuntivo. Attraverso l'analisi statica non solo non riusciamo a determinare il valore inviato sul canale \texttt{in} nè entrambi i valori inviati sul canale \texttt{out}. \bigskip \\
La soluzione da noi adottata è in realtà molto semplice e permette di mantenere una sufficente espressività del modello: generalizziamo $\mathcal{M}$ all'\emph{insieme dei tipi} dei messaggi scambiati, i tipi infatti possono essere inferiti e ricavati senza particolari problemi per mezzo di analisi statica. Nel caso della figura sopra $\mathcal{M}$ sarà definito come: $\mathcal{M} = \{ int, payload \}$ e le label nel Choreography Automata associato saranno del tipo $main \xrightarrow{int} worker$ oppure $worker \xrightarrow{payload} main$.

\iffalse
    \subsection{Gestione degli stati finali}
    % TODO remove or discuss
    % ? Should I discuss the approximation of final state with example of the fact that log.Fatal() which causes the program to exit with an error code + message should be handled as final state when encountered but it isn't since it would be mind blowing to determine every (also custom) method that has similar effect 
\fi

\section{Derivazione delle local views}
Una volta ottenuti tutti i metadati necessari sorge la necessità di derivare dagli stessi le local views di ogni Gorountine creata durante l'esecuzione dell'intero programma, da queste poi potremmo procedere alla costruzione della global view.\bigskip\\
Partiamo definendo la struttura dell'automa che verra prodotto durante queste fase, rispetto alla fase precedente dove l'automa è associato ad una singola funzione qui l'automma ottenuto sarà associato ad un intera Goroutine. Per i nostri scopi non siamo interessati all'intero flusso d'esecuzione bensì solo alle interazioni con i canali, allo \emph{spawn} di nuove Goroutine e alle \emph{function call} effettuate. \\
Un pattern tipico di Go è quello di avviare Goroutine passando alle stesse il canale/i su cui comunnicare, questo comporta un meccanisco di sostituzione dei \emph{parametri formali} con i \emph{parametri attuali} all'innterno dell'automa associato alla funzione. \\
Un altro aspetto da tenere in considerazione riguarda le chiamate di funzione effettuate, in questo caso per avere una migliore approssimazione serve che l'automa associato al \emph{chiamato} venga collegato all'automa del chiamante. Questo tipo di operazione ha il nome di \emph{inlining} ed è usata come ottimizzazione dai compilatori per evitare l'overhead della \emph{function call} quando possibile, esattamente come nell'inlining sostituiamo la chiamata di funzione con il corpo (nel nostro caso l'automa) della funzione stessa. Così facendo otterremo alla fine un unico automa che rappresenta l'esecuzione delle Goroutine tenendo in considerazione anche le eventuali function call fatte durante la stessa.\bigskip \\
Ora che abbiamo definito alcune problematiche da prendere in considerazione durante questa fase, vediamo l'algoritmo per l'estrazione delle local views. Fortunamente l'esistenza di una gerarchia \emph{intrinseca} nelle Goroutine ci è di aiuto poichè sappiamo che inizialmente esiste solo una Goroutine, quella che esegue il \texttt{main}, e sarà questa ad avviare le altre \emph{in cascata}

\begin{algorithm}
    \caption{Derivazione delle local views}
    \begin{algorithmic}
        \State $grSet \gets \{ main \}$
        \While{$\exists$ gr $\in grSet$ non marcato} \Comment{Per ogni Goroutine trovata}
        \ForEach {$t \in gr$} \Comment{Per ogni transizione nell'FSA di questa Goroutine}
        \If {$t.kind = Call$}
        \State espande i parametri formali con quelli attuali
        \State inline del chiamato all'interno del chiamante
        \ElsIf {$t.kind = Spawn$}
        \State espande i parametri formali con quelli attuali
        \State $grSet \gets grSet \cup \{ t.target \}$
        \EndIf
        \EndFor
        \State marca $gr$
        \EndWhile
    \end{algorithmic}
\end{algorithm}


\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,scale=1, transform shape, baseline=0]
        \node[state,initial] (A0) {$0$};
        \node[state] (A1) [right of=A0] {$1$};
        \node[state,accepting] (A2) [right of=A1] {$2$};
        \node[state] (A3) [right of=A2] {$3$};
        \node[state,initial,accepting] (B0) [below of=A1] {$0$};
        \node[state] (B1) [right of=B0] {$1$};
        \draw
        (A0) edge node{$\bigtriangleup$ worker} (A1)
        (A1) edge node{$\bigtriangleup$ worker} (A2)
        (A2) edge [bend left]node{$\rightarrow$ in} (A3)
        (A3) edge [bend left]node{$\leftarrow$ out} (A2)
        (B0) edge [bend left]node{$\leftarrow$ in} (B1)
        (B1) edge [bend left]node{$\rightarrow$ out} (B0);
    \end{tikzpicture}
    \caption{La local views per i processoi \texttt{main} e \texttt{worker} visti in \ref{lst:DynamicAnalysis}}
\end{figure}

\section{Generazione della coreografia}
TODO % TODO
