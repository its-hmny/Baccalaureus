% "Changes and adaptations" chapter
\chapter{Adattamento del modello}
\section{Obiettivi e problematiche}
L'obiettivo del progetto, ad lato livello, e' quello di prendere del codice sorgente \emph{Go} ed estarre in qualche modo il Choreography Automata associato a quel programma e che esprima in particolare come i processi interagiscono tra loro durante l'esecuzione.\\
L'esecuzione del nostro programma si divide in quattro fasi:
\begin{enumerate}
    \item \textbf{Parsing}: Il codice sorgente viene validato e trasformato in un \emph{Abstact Syntax Tree} (AST)
    \item \textbf{Analisi statica}: Viene navigato l'AST estraendo tutte le informazioni necessarie (i metadati) e salvandole in strutture dati appropriate.
    \item \textbf{Estrazione delle local views}: Partendo dai metadati si generano le local views dei vari processi (o attori).
    \item \textbf{Riconcialiazione}: Ottenere partendo dalle view locali un singolo Choreography Automata che rappresenti l'intera coreografia del sistema (view globale).
\end{enumerate}
Questo approccio e' chiaramente \emph{Bottom-Up} mentre l'approccio delle definizioni nel capitolo \ref{cap:Preliminaries} e' invece \emph{Top-Down}, infatti abbiamo visto come, partendo dal Choreography Automata possiamo ricavare le singole view locali attraverso l'operazione di \emph{Proiezione}.\\
Come accennato sopra si rende necessaria l'implementazione di un'operazione opposta alla proiezione, chiamata \emph{riconciliazione} che permetta di ottenere un view globale a partire dalle sue singole componenti, ovvero le view locali.

\subsection{Limiti dell'analisi statica}
Per quanto riguarda la fase di estrazione dei metadati, esplicata brevemente sopra, sorge una inconsistenza con la definizione formale di Choreography Automata data in precedenza: l'insieme $\mathcal{M}$ dei messagi non e' determinabile in maniera precisa attraverso l'analisi statica.
Questo tipo di analisi viene effettuata infatti utilizzando solo il codice sorgente e ricavando dei dati senza eseguire in alcun modo il codice stesso (per questo motivo e' detta \emph{statica}) e nel caso di Go e altri linguaggi non e' possibile solo attraverso l'analisi statica ricavare il valore esatto di tutti i messaggi, questo perche' detto valore puo' essere soggetto a vari tipi di \emph{side effect} durante l'esecuzione, puo' essere legato a parametri temporali (timestamp o chron) o input forniti dall'utente. Tutti questi \emph{aspetti}  non sono \emph{catturabili} attraverso l'analisi statica e dunque devono essere  gestiti in maniera oppurtuna.\\ \\
L'esempio sottostante mostra un caso di possibile di codice sorgente Go in cui l'analisi statica non riesce a catturare i valori effettivi dei vari messaggi scambiati tra i processi:

\lstinputlisting[language=Go]{Snippets/DynamicAnalysis.go}
 
Come possiamo vedere il programma mostrato e' in realta' alquanto banale il processo \emph{main} genera un intero random che poi invia su un canale precedentemente condiviso con i due processi \emph{worker}, uno dei due processi ricevera' questo intero lo incrementera' e poi lo reinviera' su un canale di output con in aggiunta un timestamp del momento dell'invio. Attraverso l'analisi statica non solo non riusciamo a determinare il valore inviato sul canale "in" ne' entrambi i valori inviati sul canale "out". \\\\
Una possibile soluzione a questo tipo di problemi puo' essere quello di utilizzare un tipo di analisi detta dinamica dove essenzialmente si osserva il programma mentre questo esegue e si raccolgono dati di esecuzione a runtime, questo tipo di analisi risolverebbe il problema posto sopra ma allo stesso tempo ne introrubbe alcuni nuovi. L'analisi dinamica presenta per esempio problemi di \emph{incompletezza dei dati} per esempio: prendiamo un costrutto \emph{if-then-else}, sappiamo che a \emph{runtime} l'esecuzione entrera' in uno o nell'altro ramo questo tuttavia significa che saremo in grado di estrarre informazioni solo riguardanti il ramo in cui l'esecuzione si e' svolta e non conosceremo nulla di quanto succede nell'altro. Questo problema diventa ancora piu' evidente per codice che non e' \emph{centrale} nel nostro programma, ovvero quel codice che non essendo \emph{core} viene eseguito di rado e solo al sussistere di condizioni particolari.\\\\ 
% TODO: Add citation to SW Eng. paper
La soluzione adottata qui e' in realta' molto semplice: prendiamo $\mathcal{M}$ non come l'insieme dei messaggi scambiati tra i partecipante ma come l'\emph{insieme dei tipi} dei messaggi scambiati, i tipi infatti possono essere inferiti e ricavati senza particolari problemi per mezzo di analisi statica e non limitano l'espressivita' del modello. Nel caso della figura sopra $\mathcal{M}$ sara' definito come segue: $\mathcal{M} = \{ int, payload \}$ e le label nel Choreography Automata associato saranno del tipo $main \xrightarrow{int} worker$ oppure $int \xrightarrow{payload} main$.

\subsection{Particolarita' di Go}