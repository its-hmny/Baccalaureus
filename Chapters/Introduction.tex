% Introduction chapter
\chapter{Introduzione}
Negli ultimi anni si è visto un progressivo aumento nell'utilizzo di \emph{sistemi distribuiti} e delle cosiddette \emph{architetture orientate ai microservizi} così come un rinnovato interesse verso lo sviluppo concorrente.\\
Questo nuovo interesse ha portato cambiamenti  nei linguaggi di programmazione e nel \emph{language design}, si è cercato infatti di venire incontro alle richieste dei programmatori facilitando l'approccio del linguaggio alla concorrenza. Ricordiamo infatti che alcuni linguaggi non offrivano funzionalità native o talvolta le API fornite erano troppo complesse ed intricate per garantirne un utilizzo chiaro e, più in generale, la concorrenza era un \emph{afterthought} durante la progettazione di un linguaggio. Alcuni esempi pratici di questo rinnovato \emph{focus} verso la concorrenza possono essere visti in nuovi linguaggi di programmazione come Go\cite{Golang} ed Elixir\cite{Elixir} che offrono un approccio semplificato e più chiaro alla concorrenza ma anche in linguaggi più consolidati come C++\cite{C_Plus_Plus}, che con lo standard 20 ha introdotto costrutti che facilitano l'utilizzo rispetto alle implementazioni precedenti.\bigskip \\
Tuttavia è estremamente complesso sviluppare un sistema concorrente (o distribuito) esente da errori, allo stesso modo si presentano varie problematiche legate al \emph{testing} e \emph{debugging} dello stesso, in entrambi i casi si fatica a riprodurre il bug o a testare tutte le casistiche possibili. Questo aspetto di difficoltà è intrinsecamente legato alla natura non deterministica di un sistema concorrente che rende difficile riprodurre una definita situazione. Inoltre questi problemi di riproducibilità e validazione crescono esponenzialmente in difficoltà al crescere della complessità del sistema stesso.\bigskip \\
Da queste problematiche nasce dunque la necessità di avere strumenti che assistano lo sviluppatore, per questo motivo parallelamente al trend sopra descritto, sono stati proposti nuovi \emph{paradigmi} e \emph{modelli teorici} che mirano ad esemplificare la scrittura di programmi concorrenti, tra questi troviamo le \emph{coreografie}\cite{Choreographies}.\\
L'idea alla base delle coreografie è quella di definire un metodo standard per rappresentare le interazioni tra due o più processi durante l'esecuzione in un sistema concorrente. Le coreografie forniscono al programmatore la possibilità di osservare e analizzare le interazioni che avvengono tra i partecipanti in fase di debug e, allo stesso modo, possono fornire uno strumento per la descrizione delle stesse durante la fase progettuale.\bigskip \\
Tipicamente nelle coreografie i processi comunicano tra loro attraverso \emph{message passing}, avremo quindi una primitiva del tipo:
\begin{center}
    $Alice \rightarrow Bob : message$
\end{center}
per indicare che Alice sta inviando un messaggio \emph{message} a Bob. La caratteristica che distingue le coreografie dagli altri paradigmi consiste nel fatto che quest'ultime forniscono 2 tipi di \emph{view} diverse:
\begin{itemize}
    \item \textbf{View globale}: la descrizione dal punto di visto \emph{olistico} dell'intero sistema
    \item \textbf{View locale}: la descrizione di un singolo componente \emph{in isolamento}
\end{itemize}
È sempre possibile, partendo dalla global view, ottenere una sua local view attraverso l'operazione di \emph{proiezione} ed è anche possibile unire più global view insieme mediante l'operazione di \emph{composizione}\cite{CA_Composition}. Oltre a queste operazioni una coreografia che soddisfa certe proprietà ed è dunque \emph{ben formata} permette di fare assunzioni riguardo all'assenza dei classici problemi di programmazione concorrente come \emph{deadlocks}, \emph{race conditions} e \emph{liveness} fornendo al programmatore uno strumento di verifica per il suo codice.\bigskip \\
In questa tesi viene presentato \emph{Choreia}, un tool di analisi statica che permette di ricavare da del codice sorgente Go il Choregraphy Automata ad esso associato. I Choreography Automata sono un \emph{modello} per descrivere le coreografie basato su \emph{automi a stati finiti (FSA)}, un particolare vantaggio dei Choreography Automata è la possibilità di poter riutilizzare tutte le nozioni teoriche già esistenti in letteratura sugli automi a stati finiti. Oltre ad una descrizioni approfondita del tool e delle nozioni alla base dello stesso verrano introdotte anche le \emph{Communicating Finite State Machine} per la descrizione delle local views e gli algoritmi di proiezione e composizione. Sempre in questa tesi verrà presentato un algoritmo per la composizione di multiple local views in una unica global view, andando difatti a definire un'operazione inversa alla proiezione, quest'ultima sarà direttamente derivata dall'algoritmo di composizione tra global views.
